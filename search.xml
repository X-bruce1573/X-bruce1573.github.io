<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于ICP的点云融合拼接</title>
      <link href="2022/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/"/>
      <url>2022/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="基于ICP的点云融合拼接"><a href="#基于ICP的点云融合拼接" class="headerlink" title="基于ICP的点云融合拼接"></a>基于ICP的点云融合拼接</h1><blockquote><p>实际应用中基于单个雷达扫描的局限性（遮挡，特征信息不全问题），我们需要将不同坐标系下的点云进行拼接融合，以最大程度上还原真实场景</p></blockquote><h2 id="一、ICP"><a href="#一、ICP" class="headerlink" title="一、ICP"></a>一、ICP</h2><p>​       ICP即迭代最近点算法，通过不断调整，把不同角度的3D点数据整合到一个完整的模型中。它的目的在于在一个全局坐标系下找到不同视角的定位与定向，两个视角交叉部分重叠完好为最优，给定输入数据集，首先做一个估计，然后通过旋转和平移变换一个数据集，找到一个正确的点集对应方式完美匹配</p><h2 id="二、PCD文件读取与可视化"><a href="#二、PCD文件读取与可视化" class="headerlink" title="二、PCD文件读取与可视化"></a>二、PCD文件读取与可视化</h2><p><strong>数据集源自于通过RSview保存的两个不同坐标系下的Pcap文件，通过RSlidar雷达驱动编译运行转化为了Pcd文件，其可视化如下图</strong></p><img src="/2022/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/1.png" class=""><p>​                                                     测顶雷达</p><img src="/2022/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/2.png" class=""><p>​                                                                测边雷达</p><h2 id="三、滤除异常点"><a href="#三、滤除异常点" class="headerlink" title="三、滤除异常点"></a>三、滤除异常点</h2><p><strong>数据显示如下</strong>：</p><img src="/2022/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/3.png" class=""><p>由上图可知，PCD点云数据中存在nan异常点，对于融合拼接效果有影响，因此我们需要去除异常点</p><img src="/2022/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/4.png" class=""><p>由上图可知，异常点过滤成功！！！</p><h2 id="四、点云拼接融合"><a href="#四、点云拼接融合" class="headerlink" title="四、点云拼接融合"></a>四、点云拼接融合</h2><p>结果如下图：</p><img src="/2022/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/01/07/ji-yu-icp-de-dian-yun-rong-he-pin-jie/5.png" class=""><p>拼接融合效果良好！！！</p>]]></content>
      
      
      <categories>
          
          <category> ICP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCL </tag>
            
            <tag> 点云拼接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOAM源码解析1一scanRegistration</title>
      <link href="2022/01/07/loam-yuan-ma-jie-xi-1-yi-scanregistration/"/>
      <url>2022/01/07/loam-yuan-ma-jie-xi-1-yi-scanregistration/</url>
      
        <content type="html"><![CDATA[<blockquote><p>鉴于工作和学习需要，学习了激光<code>salm</code>算法<code>loam</code>，并阅读了作者的原版论文，现将学习过程中的理解与一些源码剖析记录整理下来，也是对于学习<code>slam</code>的阶段性总结!!!</p></blockquote><h1 id="一、综述"><a href="#一、综述" class="headerlink" title="一、综述"></a>一、综述</h1><p><a href="https://link.zhihu.com/?target=https://www.ri.cmu.edu/pub_files/2014/7/Ji_LidarMapping_RSS2014_v8.pdf">LOAM</a>这篇论文是发表于2014年RSS的文章，全称为：LOAM: Lidar Odometry and Mapping in Real-time . LOAM是基于激光雷达而搭建的在ROS平台下的SLAM系统，一共分为scanRegistration提取特征点、laserOdometry 10HZ估计位姿、laserMapping 1HZ构建三维地图transforMaintenance 位姿优化等四个模块。</p><p>本文对今天对第一部分Point Clond Registration模板，scanRegistration.cpp进行分析，主要完成的工作有：对点云和IMU数据预处理、对接收的点云数据划分到不同线中存储、特征点（边缘点+平面点）提取等。</p><h1 id="二、scanRegistration-cpp"><a href="#二、scanRegistration-cpp" class="headerlink" title="二、scanRegistration.cpp"></a>二、scanRegistration.cpp</h1><blockquote><p>从main函数开始 在ros中订阅了2个话题，发布了6个话题。两个主要的回调函数：laserCloudHandler、imuHandler分别处理点云和IMU数据。其中，最主要的是laserCloudHandler回调函数。</p></blockquote><h2 id="2-1-main函数"><a href="#2-1-main函数" class="headerlink" title="2.1 main函数"></a>2.1 main函数</h2><pre class=" language-c++"><code class="language-c++">int main(int argc, char** argv){  //ros::init(argc, argv, "scanRegistration");  ros::init(argc, argv, "scanRegistration");  ros::NodeHandle nh;//2个订阅者，6个发布者 /*   * 参数1：话题名称       * 参数2：信息队列长度       * 参数3：回调函数，每当一个信息到来的时候，这个函数会被调用       * 返回一个ros::Subscriber类的对象，当此对象的所有引用都被销毁是，本节点将不再是该话题的订阅者    */    ros::Subscriber subLaserCloud = nh.subscribe<sensor_msgs::PointCloud2>                                   ("/velodyne_points", 2, laserCloudHandler);//订阅雷达数据  ros::Subscriber subImu = nh.subscribe<sensor_msgs::Imu> ("/imu/data", 50, imuHandler);订阅imu数据/*   * 我们通过advertise() 函数指定我们如何在给定的topic上发布信息   * 它会触发对ROS master的调用，master会记录话题发布者和订阅者   * 在advertise()函数执行之后，master会通知每一个订阅此话题的节点   * 两节点间由此可以建立直接的联系   * advertise()会返回一个Publisher对象，使用这个对象的publish方法我们就可以在此话题上发布信息   * 当返回的Publisher对象的所有引用都被销毁的时候，本节点将不再是该话题的发布者   * 此函数是一个带模板的函数，需要传入具体的类型进行实例化   * 传入的类型就是要发布的信息的类型，在这里是String   * 第一个参数是话题名称   * 第二个参数是信息队列的长度，相当于信息的一个缓冲区   * 在我们发布信息的速度大于处理信息的速度时   * 信息会被缓存在先进先出的信息队列里   */  //指定发布者话题的对象  pubLaserCloud = nh.advertise<sensor_msgs::PointCloud2>                                 ("/velodyne_cloud_2", 2);//发布按线分类后的点云  pubCornerPointsSharp = nh.advertise<sensor_msgs::PointCloud2>                                        ("/laser_cloud_sharp", 2);//边界线上特殊点云  pubCornerPointsLessSharp = nh.advertise<sensor_msgs::PointCloud2>                                            ("/laser_cloud_less_sharp", 2);  pubSurfPointsFlat = nh.advertise<sensor_msgs::PointCloud2>                                       ("/laser_cloud_flat", 2);//面上特征点云  pubSurfPointsLessFlat = nh.advertise<sensor_msgs::PointCloud2>                                           ("/laser_cloud_less_flat", 2);  pubImuTrans = nh.advertise<sensor_msgs::PointCloud2> ("/imu_trans", 5);//发布imu处理数据  ros::spin();//每执行一次一直等待处理回调函数  return 0;}</code></pre><h2 id="2-2-回调函数-laserCloudHandler"><a href="#2-2-回调函数-laserCloudHandler" class="headerlink" title="2.2 回调函数 laserCloudHandler"></a>2.2 回调函数 laserCloudHandler</h2><blockquote><p>主要包括以下内容：</p><p>1、点云预处理：过滤无效点、计算起始和终止点的方位角 2、<strong>根据每个点的仰角将点划入不同线中</strong>，共16线，记录线束号和获取的相对时间（也就是代码中的intensity，这个不是强度） 3、使用IMU数据插值计算点云中点的位置，消除由于非匀速运动造成的运动畸变 4、计算所有点的曲率，剔除两类点 5、<strong>提取边缘点和平面点</strong> 6、ROS发布消息</p></blockquote><pre class=" language-c++"><code class="language-c++">/*对接受到的点云进行预处理，完成分类将点云划入不同的线性存储；对其进行特征分类*/void laserCloudHandler(const sensor_msgs::PointCloud2ConstPtr& laserCloudMsg){//-------------------1、点云预处理-----------------------//    if (!systemInited) {    systemInitCount++;    if (systemInitCount >= systemDelay) {      //延时作用，保证imu有数据后再调用该回调函数      systemInited = true;    }    return;//不满足条件到此处就不往下执行了，最下面的也不会执行了，直接跳出回调函数  }  //N_SCANS（16）保存每一点的起始与终止索引  std::vector<int> scanStartInd(N_SCANS, 0);//定义了16个整形变量，每个变量的初值为1  std::vector<int> scanEndInd(N_SCANS, 0);  //雷达的时间戳  double timeScanCur = laserCloudMsg->header.stamp.toSec();  pcl::PointCloud<pcl::PointXYZ> laserCloudIn;  //转化为模板点云  pcl::fromROSMsg(*laserCloudMsg, laserCloudIn);  std::vector<int> indices;  //去除无效点  pcl::removeNaNFromPointCloud(laserCloudIn, laserCloudIn, indices);  int cloudSize = laserCloudIn.points.size();  //计算点云的起始角度与终止角度  //atan2的范围是[-180,180]，atan的范围是[-90,90]  //扫描开始点的旋转角,atan2范围[-pi,+pi],计算旋转角时取负号是因为velodyne是顺时针旋转  float startOri = -atan2(laserCloudIn.points[0].y, laserCloudIn.points[0].x);  float endOri = -atan2(laserCloudIn.points[cloudSize - 1].y,                        laserCloudIn.points[cloudSize - 1].x) + 2 * M_PI;/*将起止角度差值约束到pi-3pi之间*/  if (endOri - startOri > 3 * M_PI) {    endOri -= 2 * M_PI;  } else if (endOri - startOri < M_PI) {    endOri += 2 * M_PI;  }//-----------------2、根据角度将点划入不同的线中------------------//  /*遍历所有点，计算点的仰角，根据仰角过滤16线以外的点，并为每个点分配激光线号scanID根据点云中点旋转角度和整个周期旋转角度的比率获得相对时间relTime，并获得点强度（线号+点相对时间）根据扫描线是否过半，选择与起始位置还是终止位置进行差值计算，从而进行补偿*/  bool halfPassed = false;//为了判断雷达扫描的点是否过半  int count = cloudSize;  PointType point;//承载雷达数据点的数据类型  std::vector<pcl::PointCloud<PointType> > laserCloudScans(N_SCANS);//存储16线点云的vector，根据仰角排列激光线号，velodyne每两个scan之间间隔2度  //遍历所有点，计算每个点的角度  for (int i = 0; i < cloudSize; i++) {    // 雷达坐标系是x向前，y向左，z向上    // 机器坐标系为z向前，x向左，y向上    point.x = laserCloudIn.points[i].y;    point.y = laserCloudIn.points[i].z;    point.z = laserCloudIn.points[i].x;    //计算点的仰角，过滤16线以外的点    float angle = atan(point.y / sqrt(point.x * point.x + point.z * point.z)) * 180 / M_PI;    int scanID;//每个id里面都有不止一个角    int roundedAngle = int(angle + (angle<0.0?-0.5:+0.5)); //针对仰角进行四舍五入    if (roundedAngle > 0){      scanID = roundedAngle;    }    else {      scanID = roundedAngle + (N_SCANS - 1);    }    //过滤点，只挑选[-15度，+15度]范围内的点,scanID属于[0,15]，剔除16线以外的杂点。    if (scanID > (N_SCANS - 1) || scanID < 0 ){      count--;      continue;    }    // 3.根据扫描线是否旋转过半，选择与起始位置还是终止位置进行差值计算，从而进行补偿    float ori = -atan2(point.x, point.z);//（0--2pi）    //如果没有旋转过半    if (!halfPassed) {      //确保-pi/2 < ori - startOri < 3*pi/2      if (ori < startOri - M_PI / 2) {        ori += 2 * M_PI;      } else if (ori > startOri + M_PI * 3 / 2) {        ori -= 2 * M_PI;      }      if (ori - startOri > M_PI) {        halfPassed = true;      }        }    //如果旋转过半     else {      ori += 2 * M_PI;//先加2*pi    //确保-3*pi/2 < ori - endOri < pi/2      if (ori < endOri - M_PI * 3 / 2) {        ori += 2 * M_PI;      } else if (ori > endOri + M_PI / 2) {        ori -= 2 * M_PI;      }     }    //点云中点的相对时间:点旋转的角度与整个周期旋转角度的比率, -0.5 < relTime < 1.5    float relTime = (ori - startOri) / (endOri - startOri);    //点强度=线号+点相对时间（即一个整数+一个小数，整数部分是线号scanID，小数部分是该点的相对时间）    //匀速扫描：根据当前扫描的角度和扫描周期计算相对扫描起始位置的时间    point.intensity = scanID + scanPeriod * relTime;// scanPeriod 扫描一圈0.1s// -----------------3、使用IMU数据进行插值计算点云的中点的位置，消除由于非匀速运动造成的运动畸变----------------//    if (imuPointerLast >= 0) {//当imu有数据时      float pointTime = relTime * scanPeriod;//当前激光点的偏移时间=激光点相对时间所占比例*周期      while (imuPointerFront != imuPointerLast) {        //点时间=当前点云时间戳+当前激光点的偏移时间        //寻找是否有点云时间<imu的时间戳        if (timeScanCur + pointTime < imuTime[imuPointerFront]) {          break;        }        imuPointerFront = (imuPointerFront + 1) % imuQueLength;      }      //当前激光点的time大于找到的对应惯导数据的time,则惯导数据采用当前值      if (timeScanCur + pointTime > imuTime[imuPointerFront]) {        imuRollCur = imuRoll[imuPointerFront];        imuPitchCur = imuPitch[imuPointerFront];        imuYawCur = imuYaw[imuPointerFront];        imuVeloXCur = imuVeloX[imuPointerFront];        imuVeloYCur = imuVeloY[imuPointerFront];        imuVeloZCur = imuVeloZ[imuPointerFront];        imuShiftXCur = imuShiftX[imuPointerFront];        imuShiftYCur = imuShiftY[imuPointerFront];        imuShiftZCur = imuShiftZ[imuPointerFront];            }      //找到了点云时间戳小于IMU时间戳的IMU位置,则该点必处于imuPointerBack和imuPointerFront之间      //据此线性插值（根据距离分配比重），计算点云点的速度，位移和欧拉角       else {        int imuPointerBack = (imuPointerFront + imuQueLength - 1) % imuQueLength;        //按时间距离计算权重分配比率        float ratioFront = (timeScanCur + pointTime - imuTime[imuPointerBack])                          / (imuTime[imuPointerFront] - imuTime[imuPointerBack]);        float ratioBack = (imuTime[imuPointerFront] - timeScanCur - pointTime)                         / (imuTime[imuPointerFront] - imuTime[imuPointerBack]);        imuRollCur = imuRoll[imuPointerFront] * ratioFront + imuRoll[imuPointerBack] * ratioBack;        imuPitchCur = imuPitch[imuPointerFront] * ratioFront + imuPitch[imuPointerBack] * ratioBack;        if (imuYaw[imuPointerFront] - imuYaw[imuPointerBack] > M_PI) {          imuYawCur = imuYaw[imuPointerFront] * ratioFront + (imuYaw[imuPointerBack] + 2 * M_PI) * ratioBack;        } else if (imuYaw[imuPointerFront] - imuYaw[imuPointerBack] < -M_PI) {          imuYawCur = imuYaw[imuPointerFront] * ratioFront + (imuYaw[imuPointerBack] - 2 * M_PI) * ratioBack;        } else {          imuYawCur = imuYaw[imuPointerFront] * ratioFront + imuYaw[imuPointerBack] * ratioBack;        }        //更新速度和偏移量        imuVeloXCur = imuVeloX[imuPointerFront] * ratioFront + imuVeloX[imuPointerBack] * ratioBack;        imuVeloYCur = imuVeloY[imuPointerFront] * ratioFront + imuVeloY[imuPointerBack] * ratioBack;        imuVeloZCur = imuVeloZ[imuPointerFront] * ratioFront + imuVeloZ[imuPointerBack] * ratioBack;        imuShiftXCur = imuShiftX[imuPointerFront] * ratioFront + imuShiftX[imuPointerBack] * ratioBack;        imuShiftYCur = imuShiftY[imuPointerFront] * ratioFront + imuShiftY[imuPointerBack] * ratioBack;        imuShiftZCur = imuShiftZ[imuPointerFront] * ratioFront + imuShiftZ[imuPointerBack] * ratioBack;      }      //如果是第一个点,记住点云起始位置的速度，位移，欧拉角      if (i == 0) {        imuRollStart = imuRollCur;        imuPitchStart = imuPitchCur;        imuYawStart = imuYawCur;        imuVeloXStart = imuVeloXCur;        imuVeloYStart = imuVeloYCur;        imuVeloZStart = imuVeloZCur;        imuShiftXStart = imuShiftXCur;        imuShiftYStart = imuShiftYCur;        imuShiftZStart = imuShiftZCur;      }      //计算之后每个点相对于第一个点的由于加减速非匀速运动产生的位移、速度畸变，并对点云中的每个点位置信息重新补偿矫正      // Lidar位移、速度转移到IMU起始坐标系下       else {        //当不为初始值时，去除imu加速度造成运动畸变的影响        ShiftToStartIMU(pointTime);//相对于原始点的位移畸变        VeloToStartIMU();//相对于原始点的位移畸变        TransformToStartIMU(&point);//减去非匀速位移畸变的值      }    }    //接着将激光点存入laserCloudScans对应的scanID中，从而完成按线分类工作。按照线号从小到大    //通过laserCloud指针将N_SCANS线的激光数据组成pcl点云    laserCloudScans[scanID].push_back(point);//将每个补偿矫正的点放入对应线号的容器中  }  cloudSize = count;//------------------------4、计算所有点的曲率、剔除两类点-------------------------////1、被斜面挡住的点   2、入射角平面与激光平行的点//特征点的提取，通过遍历每个点与相邻10个点坐标（除了前五个和后五个）差值的平方来代表曲率，计算各点曲率并找到所有线的起点终点位置  pcl::PointCloud<PointType>::Ptr laserCloud(new pcl::PointCloud<PointType>());  for (int i = 0; i < N_SCANS; i++) {    *laserCloud += laserCloudScans[i];//将所有的点按照线号从小到大放入一个容器  }  int scanCount = -1;  //1针对按线分类后的点云，通过激光点左右各5个点进行曲率计算：  //该点与周围10个点的偏差  for (int i = 5; i < cloudSize - 5; i++) {    float diffX = laserCloud->points[i - 5].x + laserCloud->points[i - 4].x                 + laserCloud->points[i - 3].x + laserCloud->points[i - 2].x                 + laserCloud->points[i - 1].x - 10 * laserCloud->points[i].x                 + laserCloud->points[i + 1].x + laserCloud->points[i + 2].x                + laserCloud->points[i + 3].x + laserCloud->points[i + 4].x                + laserCloud->points[i + 5].x;    float diffY = laserCloud->points[i - 5].y + laserCloud->points[i - 4].y                 + laserCloud->points[i - 3].y + laserCloud->points[i - 2].y                 + laserCloud->points[i - 1].y - 10 * laserCloud->points[i].y                 + laserCloud->points[i + 1].y + laserCloud->points[i + 2].y                + laserCloud->points[i + 3].y + laserCloud->points[i + 4].y                + laserCloud->points[i + 5].y;    float diffZ = laserCloud->points[i - 5].z + laserCloud->points[i - 4].z                 + laserCloud->points[i - 3].z + laserCloud->points[i - 2].z                 + laserCloud->points[i - 1].z - 10 * laserCloud->points[i].z                 + laserCloud->points[i + 1].z + laserCloud->points[i + 2].z                + laserCloud->points[i + 3].z + laserCloud->points[i + 4].z                + laserCloud->points[i + 5].z;    cloudCurvature[i] = diffX * diffX + diffY * diffY + diffZ * diffZ;//记录每个点的曲率    cloudSortInd[i] = i;//表示当前点在点云中索引    cloudNeighborPicked[i] = 0;//用于标记是否为筛选过的点    cloudLabel[i] = 0;//用于标记特征点为边界线还是平面特征点    //每个scan，只有第一个符合的点会进来，因为每个scan的点都在一起存放    if (int(laserCloud->points[i].intensity) != scanCount) {      scanCount = int(laserCloud->points[i].intensity);//控制每个scan只进入第一个点      if (scanCount > 0 && scanCount < N_SCANS) {        scanStartInd[scanCount] = i + 5;// scan起始位置的索引（去除前5个点）        scanEndInd[scanCount - 1] = i - 5;// scan终止位置的索引（去除后5个点）      }    }  }   //第一个scan曲率点有效点序从第5个开始，最后一个激光线结束点序size-5，直接赋值即可  scanStartInd[0] = 5;//第一条线的起始位置  scanEndInd.back() = cloudSize - 5; //最后一条线的终止位置  // 2.挑选点，排除容易被斜面挡住的点以及离群点，有些点容易被斜面挡住，  // 而离群点可能出现带有偶然性，这些情况都可能导致前后两次扫描不能被同时看到  for (int i = 5; i < cloudSize - 6; i++) {//与后一个点的差值，所以减6    float diffX = laserCloud->points[i + 1].x - laserCloud->points[i].x;    float diffY = laserCloud->points[i + 1].y - laserCloud->points[i].y;    float diffZ = laserCloud->points[i + 1].z - laserCloud->points[i].z;    //计算有效曲率点与后一个点之间的距离平方和    float diff = diffX * diffX + diffY * diffY + diffZ * diffZ;        if (diff > 0.1) {//若两个点之间距离的平方大于0.1，说明这两点存在一定的距离，      //计算点的深度信息      float depth1 = sqrt(laserCloud->points[i].x * laserCloud->points[i].x +                      laserCloud->points[i].y * laserCloud->points[i].y +                     laserCloud->points[i].z * laserCloud->points[i].z);      float depth2 = sqrt(laserCloud->points[i + 1].x * laserCloud->points[i + 1].x +                      laserCloud->points[i + 1].y * laserCloud->points[i + 1].y +                     laserCloud->points[i + 1].z * laserCloud->points[i + 1].z);      if (depth1 > depth2) {        //将较长边（i）按比例收缩到与短边i+1平齐，构成以i,i+1的长度为腰的等腰三角形        diffX = laserCloud->points[i + 1].x - laserCloud->points[i].x * depth2 / depth1;        diffY = laserCloud->points[i + 1].y - laserCloud->points[i].y * depth2 / depth1;        diffZ = laserCloud->points[i + 1].z - laserCloud->points[i].z * depth2 / depth1;        //根据 x=sinx（近似）=底/边 ,求得当前激光点与后一点的夹角        //实际表示i与i+1夹角小于5.732度 sin(5.732) ~= 0.1 认为被遮挡        // 边长比也即是弧度值，若小于0.1，说明夹角比较小，斜面比较陡峭,点深度变化比较剧烈,点处在近似与激光束平行的斜面上        //3、排除容易被斜面挡住的点        if (sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ) / depth2 < 0.1) {          //深度大的点以及前面5个点，全部标记为不是特征点，因为不稳定          cloudNeighborPicked[i - 5] = 1;          cloudNeighborPicked[i - 4] = 1;          cloudNeighborPicked[i - 3] = 1;          cloudNeighborPicked[i - 2] = 1;          cloudNeighborPicked[i - 1] = 1;          cloudNeighborPicked[i] = 1;        }      } else {//将较长边（i+1）按比例收缩到与短边i平齐，构成以i,i+1的长度为腰的等腰三角形        diffX = laserCloud->points[i + 1].x * depth1 / depth2 - laserCloud->points[i].x;        diffY = laserCloud->points[i + 1].y * depth1 / depth2 - laserCloud->points[i].y;        diffZ = laserCloud->points[i + 1].z * depth1 / depth2 - laserCloud->points[i].z;        //深度大的点以及后面5个点，全部标记为不是特征点，因为不稳定        if (sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ) / depth1 < 0.1) {          cloudNeighborPicked[i + 1] = 1;          cloudNeighborPicked[i + 2] = 1;          cloudNeighborPicked[i + 3] = 1;          cloudNeighborPicked[i + 4] = 1;          cloudNeighborPicked[i + 5] = 1;          cloudNeighborPicked[i + 6] = 1;        }      }    }    //4、排除与激光平行的点    //计算当前点与前一点的距离的平方    float diffX2 = laserCloud->points[i].x - laserCloud->points[i - 1].x;    float diffY2 = laserCloud->points[i].y - laserCloud->points[i - 1].y;    float diffZ2 = laserCloud->points[i].z - laserCloud->points[i - 1].z;    float diff2 = diffX2 * diffX2 + diffY2 * diffY2 + diffZ2 * diffZ2;    //计算当前点的深度（x2+y2+z2）    float dis = laserCloud->points[i].x * laserCloud->points[i].x              + laserCloud->points[i].y * laserCloud->points[i].y              + laserCloud->points[i].z * laserCloud->points[i].z;    //如果当前点与前后点距离的平方都>0.0002倍当前点的深度，则当前点入射角与物理表面平行，当前点不可作为特征点    if (diff > 0.0002 * dis && diff2 > 0.0002 * dis) {      cloudNeighborPicked[i] = 1;    }  }//--------------------------5、根据曲率排序、提取边缘点、平面点，进行特征分类----------------------------//  pcl::PointCloud<PointType> cornerPointsSharp;//存储每段中曲率较大的两个点  pcl::PointCloud<PointType> cornerPointsLessSharp;//存储边缘点  pcl::PointCloud<PointType> surfPointsFlat;//用于存储曲率最小的几个点  pcl::PointCloud<PointType> surfPointsLessFlat;//存储平面点  //首先对于每一层激光点(总16层)，将每层区域分成6份，起始位置为sp，终止位置为ep，然后对曲率从小到大进行排序  for (int i = 0; i < N_SCANS; i++) {    pcl::PointCloud<PointType>::Ptr surfPointsLessFlatScan(new pcl::PointCloud<PointType>);    //每个线分6段，确保周围都有点被选作特征点，sp/ep分别为各段起始和终止位置    for (int j = 0; j < 6; j++) {      //六等份起点：sp = scanStartInd + (scanEndInd - scanStartInd)*j/6      int sp = (scanStartInd[i] * (6 - j)  + scanEndInd[i] * j) / 6;      //六等份终点：ep = scanStartInd - 1 + (scanEndInd - scanStartInd)*(j+1)/6      int ep = (scanStartInd[i] * (5 - j)  + scanEndInd[i] * (j + 1)) / 6 - 1;      //每一段，曲率按照升序排放      for (int k = sp + 1; k <= ep; k++) {        for (int l = k; l >= sp + 1; l--) {          if (cloudCurvature[cloudSortInd[l]] < cloudCurvature[cloudSortInd[l - 1]]) {            int temp = cloudSortInd[l - 1];            cloudSortInd[l - 1] = cloudSortInd[l];            cloudSortInd[l] = temp;          }        }      }      //筛选边缘点：每段曲率很大或则比较大的点      int largestPickedNum = 0;      for (int k = ep; k >= sp; k--) {        int ind = cloudSortInd[k];//设定为曲率最大的点序        //如果该点序的点没有被标记为不可取特征点且曲率大于阈值        if (cloudNeighborPicked[ind] == 0 &&            cloudCurvature[ind] > 0.1) {                  largestPickedNum++;          //挑选曲率最大的前2个点放入sharp点集合          if (largestPickedNum <= 2) {            cloudLabel[ind] = 2;//2代表曲率很大            cornerPointsSharp.push_back(laserCloud->points[ind]);//保存sharp点云中             cornerPointsLessSharp.push_back(laserCloud->points[ind]);//同时保存在lessSharp点云中          }//挑选曲率再打的前20个点保存在lessSharp点云中（包括前两个标记为2的点）           else if (largestPickedNum <= 20) {            cloudLabel[ind] = 1;//后18个lesssharp特征线点标记为1            cornerPointsLessSharp.push_back(laserCloud->points[ind]);          } else {            break;          }          cloudNeighborPicked[ind] = 1;//标记为不可用点          //将曲率比较大的点的前后各5个连续距离比较近的点筛选出去，防止特征点聚集，使得特征点在每个方向上尽量分布均匀          //对ind点周围的点是否能作为特征点进行判断   除非距离大于阈值，否则前后各五个点不能作为特征点          for (int l = 1; l <= 5; l++) {            float diffX = laserCloud->points[ind + l].x                         - laserCloud->points[ind + l - 1].x;            float diffY = laserCloud->points[ind + l].y                         - laserCloud->points[ind + l - 1].y;            float diffZ = laserCloud->points[ind + l].z                         - laserCloud->points[ind + l - 1].z;            if (diffX * diffX + diffY * diffY + diffZ * diffZ > 0.05) {              break;            }            cloudNeighborPicked[ind + l] = 1;//被标记为不可用点          }          for (int l = -1; l >= -5; l--) {            float diffX = laserCloud->points[ind + l].x                         - laserCloud->points[ind + l + 1].x;            float diffY = laserCloud->points[ind + l].y                         - laserCloud->points[ind + l + 1].y;            float diffZ = laserCloud->points[ind + l].z                         - laserCloud->points[ind + l + 1].z;            if (diffX * diffX + diffY * diffY + diffZ * diffZ > 0.05) {              break;            }            cloudNeighborPicked[ind + l] = 1;          }        }      }      //平面点：挑选每个分段的曲率很小比较小的点      //从每一段曲率最小(前端)开始查找    用于确定平面点      int smallestPickedNum = 0;      for (int k = sp; k <= ep; k++) {        int ind = cloudSortInd[k];        //如果没有被标记为不可用特征点，且曲率小于0.1        if (cloudNeighborPicked[ind] == 0 &&            cloudCurvature[ind] < 0.1) {          cloudLabel[ind] = -1;//-1代表曲率很小的点          surfPointsFlat.push_back(laserCloud->points[ind]);//用于后面补偿所用          smallestPickedNum++;          if (smallestPickedNum >= 4) {////只选最小的四个，剩下的Label==0,就都是曲率比较小的            break;          }          cloudNeighborPicked[ind] = 1;          for (int l = 1; l <= 5; l++) {//同样防止特征点聚集，判断周围点是否是不可标记点            float diffX = laserCloud->points[ind + l].x                         - laserCloud->points[ind + l - 1].x;            float diffY = laserCloud->points[ind + l].y                         - laserCloud->points[ind + l - 1].y;            float diffZ = laserCloud->points[ind + l].z                         - laserCloud->points[ind + l - 1].z;            if (diffX * diffX + diffY * diffY + diffZ * diffZ > 0.05) {              break;            }            cloudNeighborPicked[ind + l] = 1;          }          for (int l = -1; l >= -5; l--) {            float diffX = laserCloud->points[ind + l].x                         - laserCloud->points[ind + l + 1].x;            float diffY = laserCloud->points[ind + l].y                         - laserCloud->points[ind + l + 1].y;            float diffZ = laserCloud->points[ind + l].z                         - laserCloud->points[ind + l + 1].z;            if (diffX * diffX + diffY * diffY + diffZ * diffZ > 0.05) {              break;            }            cloudNeighborPicked[ind + l] = 1;          }        }      }      //除了被标记过的点(本身不能作为特征点以及被标记为边界线的特征点)，其它点都作为lessFlatPoints存储到surfPointsLessFlatScan中      for (int k = sp; k <= ep; k++) {        if (cloudLabel[k] <= 0) {          surfPointsLessFlatScan->push_back(laserCloud->points[k]);        }      }    }    //由于less flat点最多，对每个分段less flat的点进行体素栅格滤波    pcl::PointCloud<PointType> surfPointsLessFlatScanDS;    pcl::VoxelGrid<PointType> downSizeFilter;    downSizeFilter.setInputCloud(surfPointsLessFlatScan);    downSizeFilter.setLeafSize(0.2, 0.2, 0.2);    downSizeFilter.filter(surfPointsLessFlatScanDS);    //less flat点汇总    surfPointsLessFlat += surfPointsLessFlatScanDS;//存储平面点  }//------------------------6、将不同的特征点打包成消息发送出去-----------------------------//  //publich消除非匀速运动畸变后的所有的点  sensor_msgs::PointCloud2 laserCloudOutMsg;  pcl::toROSMsg(*laserCloud, laserCloudOutMsg);  laserCloudOutMsg.header.stamp = laserCloudMsg->header.stamp;  laserCloudOutMsg.header.frame_id = "/camera";  pubLaserCloud.publish(laserCloudOutMsg);  //publich消除非匀速运动畸变后的边缘点  sensor_msgs::PointCloud2 cornerPointsSharpMsg;  pcl::toROSMsg(cornerPointsSharp, cornerPointsSharpMsg);  cornerPointsSharpMsg.header.stamp = laserCloudMsg->header.stamp;  cornerPointsSharpMsg.header.frame_id = "/camera";  pubCornerPointsSharp.publish(cornerPointsSharpMsg);    sensor_msgs::PointCloud2 cornerPointsLessSharpMsg;  pcl::toROSMsg(cornerPointsLessSharp, cornerPointsLessSharpMsg);  cornerPointsLessSharpMsg.header.stamp = laserCloudMsg->header.stamp;  cornerPointsLessSharpMsg.header.frame_id = "/camera";  pubCornerPointsLessSharp.publish(cornerPointsLessSharpMsg);  //publich消除非匀速运动畸变后的平面点  sensor_msgs::PointCloud2 surfPointsFlat2;  pcl::toROSMsg(surfPointsFlat, surfPointsFlat2);  surfPointsFlat2.header.stamp = laserCloudMsg->header.stamp;  surfPointsFlat2.header.frame_id = "/camera";  pubSurfPointsFlat.publish(surfPointsFlat2);  sensor_msgs::PointCloud2 surfPointsLessFlat2;  pcl::toROSMsg(surfPointsLessFlat, surfPointsLessFlat2);  surfPointsLessFlat2.header.stamp = laserCloudMsg->header.stamp;  surfPointsLessFlat2.header.frame_id = "/camera";  pubSurfPointsLessFlat.publish(surfPointsLessFlat2);  //publich IMU消息,由于循环到了最后，因此是Cur都是代表最后一个点，即最后一个点的欧拉角，畸变位移及一个点云周期增加的速度  pcl::PointCloud<pcl::PointXYZ> imuTrans(4, 1);   //起始点欧拉角  imuTrans.points[0].x = imuPitchStart;  imuTrans.points[0].y = imuYawStart;  imuTrans.points[0].z = imuRollStart;   //最后一个点的欧拉角  imuTrans.points[1].x = imuPitchCur;  imuTrans.points[1].y = imuYawCur;  imuTrans.points[1].z = imuRollCur;  //最后一个点相对于第一个点的畸变位移和速度  imuTrans.points[2].x = imuShiftFromStartXCur;  imuTrans.points[2].y = imuShiftFromStartYCur;  imuTrans.points[2].z = imuShiftFromStartZCur;  imuTrans.points[3].x = imuVeloFromStartXCur;  imuTrans.points[3].y = imuVeloFromStartYCur;  imuTrans.points[3].z = imuVeloFromStartZCur;  sensor_msgs::PointCloud2 imuTransMsg;  pcl::toROSMsg(imuTrans, imuTransMsg);  imuTransMsg.header.stamp = laserCloudMsg->header.stamp;  imuTransMsg.header.frame_id = "/camera";  pubImuTrans.publish(imuTransMsg);}</code></pre><h2 id="2-3-回调函数-imuHandler"><a href="#2-3-回调函数-imuHandler" class="headerlink" title="2.3 回调函数 imuHandler()"></a>2.3 回调函数 imuHandler()</h2><blockquote><p>减去重力对imu的影响，求出xyz轴的加速度实际值，将加速度转换到世界坐标系</p></blockquote><pre class=" language-c++"><code class="language-c++">//IMU回调函数首先读取方向角四元素到orientation，然后转换成欧拉角roll/pitch/yaw//减去重力对imu的影响，求出xyz轴的加速度实际值，将加速度转换到世界坐标系//接收imu消息，imu坐标系为x轴向前，y轴向右，z轴向上的右手坐标系void imuHandler(const sensor_msgs::Imu::ConstPtr& imuIn){  double roll, pitch, yaw;  tf::Quaternion orientation;  tf::quaternionMsgToTF(imuIn->orientation, orientation);  tf::Matrix3x3(orientation).getRPY(roll, pitch, yaw);  //统一到z轴向前,x轴向左的右手坐标系  //交换过后RPY对应fixed axes ZXY(RPY---ZXY)。Now R = Ry(yaw)*Rx(pitch)*Rz(roll).  float accX = imuIn->linear_acceleration.y - sin(roll) * cos(pitch) * 9.81;  float accY = imuIn->linear_acceleration.z - cos(roll) * cos(pitch) * 9.81;  float accZ = imuIn->linear_acceleration.x + sin(pitch) * 9.81;  //imuPointerLast作为imu各个参数数组的索引，循环累加，  imuPointerLast = (imuPointerLast + 1) % imuQueLength;  imuTime[imuPointerLast] = imuIn->header.stamp.toSec();  imuRoll[imuPointerLast] = roll;  imuPitch[imuPointerLast] = pitch;  imuYaw[imuPointerLast] = yaw;  imuAccX[imuPointerLast] = accX;  imuAccY[imuPointerLast] = accY;  imuAccZ[imuPointerLast] = accZ;  AccumulateIMUShift();}</code></pre><h2 id="2-4-AccumulateIMUShift"><a href="#2-4-AccumulateIMUShift" class="headerlink" title="2.4 AccumulateIMUShift()"></a>2.4 AccumulateIMUShift()</h2><blockquote><p>进行航距推算，假定为匀速运动推算出当前时刻的位置、速度</p></blockquote><pre class=" language-c++"><code class="language-c++">//积分速度与位移void AccumulateIMUShift(){  float roll = imuRoll[imuPointerLast];  float pitch = imuPitch[imuPointerLast];  float yaw = imuYaw[imuPointerLast];  float accX = imuAccX[imuPointerLast];  float accY = imuAccY[imuPointerLast];  float accZ = imuAccZ[imuPointerLast];  // 绕RPY旋转转换得到世界坐标系下的加速度值  //绕z轴旋转(roll)  float x1 = cos(roll) * accX - sin(roll) * accY;  float y1 = sin(roll) * accX + cos(roll) * accY;  float z1 = accZ;  //绕x轴旋转(pitch)  float x2 = x1;  float y2 = cos(pitch) * y1 - sin(pitch) * z1;  float z2 = sin(pitch) * y1 + cos(pitch) * z1;  //绕y轴旋转(yaw)  accX = cos(yaw) * x2 + sin(yaw) * z2;accY = y2;  accZ = -sin(yaw) * x2 + cos(yaw) * z2;  //上一个imu点  int imuPointerBack = (imuPointerLast + imuQueLength - 1) % imuQueLength;  //上一个点到当前点所经历的时间，即计算imu测量周期  double timeDiff = imuTime[imuPointerLast] - imuTime[imuPointerBack];  //求每个imu时间点的位移Shift与速度Velo,两点之间视为匀加速直线运动  //要求imu的频率至少比lidar高，这样的imu信息才使用，后面校正也才有意义  if (timeDiff < scanPeriod) {//（隐含从静止开始运动）imuShiftX[imuPointerLast] = imuShiftX[imuPointerBack] + imuVeloX[imuPointerBack] * timeDiff                               + accX * timeDiff * timeDiff / 2;    imuShiftY[imuPointerLast] = imuShiftY[imuPointerBack] + imuVeloY[imuPointerBack] * timeDiff                               + accY * timeDiff * timeDiff / 2;    imuShiftZ[imuPointerLast] = imuShiftZ[imuPointerBack] + imuVeloZ[imuPointerBack] * timeDiff                               + accZ * timeDiff * timeDiff / 2;    imuVeloX[imuPointerLast] = imuVeloX[imuPointerBack] + accX * timeDiff;    imuVeloY[imuPointerLast] = imuVeloY[imuPointerBack] + accY * timeDiff;    imuVeloZ[imuPointerLast] = imuVeloZ[imuPointerBack] + accZ * timeDiff;  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LOAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机接收不到雷达数据解决方案</title>
      <link href="2021/10/19/xu-ni-ji-jie-shou-bu-dao-lei-da-shu-ju-jie-jue-fang-an/"/>
      <url>2021/10/19/xu-ni-ji-jie-shou-bu-dao-lei-da-shu-ju-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机接收不到雷达数据解决方案"><a href="#虚拟机接收不到雷达数据解决方案" class="headerlink" title="虚拟机接收不到雷达数据解决方案"></a>虚拟机接收不到雷达数据解决方案</h1><img src="/2021/10/19/xu-ni-ji-jie-shou-bu-dao-lei-da-shu-ju-jie-jue-fang-an/10/19/xu-ni-ji-jie-shou-bu-dao-lei-da-shu-ju-jie-jue-fang-an/1.png" class=""><p>虚拟机-&gt;虚拟网络编辑器-&gt;<code>VMnet0</code>-&gt;桥接模式-&gt;桥接至所选即可</p><img src="/2021/10/19/xu-ni-ji-jie-shou-bu-dao-lei-da-shu-ju-jie-jue-fang-an/10/19/xu-ni-ji-jie-shou-bu-dao-lei-da-shu-ju-jie-jue-fang-an/2.png" class=""><p><code>rviz</code>显示成功！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Ubuntu18.04安装PCL</title>
      <link href="2021/08/31/ji-yu-ubuntu18-04-an-zhuang-pcl/"/>
      <url>2021/08/31/ji-yu-ubuntu18-04-an-zhuang-pcl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习PCL点云库，安装环境第一步!!!</p></blockquote><h2 id="一、安装下载各种依赖"><a href="#一、安装下载各种依赖" class="headerlink" title="一、安装下载各种依赖"></a>一、安装下载各种依赖</h2><pre class=" language-c++"><code class="language-c++">sudo apt-get update  sudo apt-get install git build-essential linux-libc-devsudo apt-get install cmake cmake-guisudo apt-get install libusb-1.0-0-dev libusb-dev libudev-devsudo apt-get install mpi-default-dev openmpi-bin openmpi-common sudo apt-get install libflann1.9 libflann-devsudo apt-get install libeigen3-devsudo apt-get install libboost-all-devsudo apt-get install libvtk7.1-qtsudo apt-get install libvtk7.1 sudo apt-get install libvtk7-qt-devsudo apt-get install libqhull* libgtest-devsudo apt-get install freeglut3-dev pkg-configsudo apt-get install libxmu-dev libxi-devsudo apt-get install mono-completesudo apt-get install openjdk-8-jdk openjdk-8-jre</code></pre><p>==以上包括X11、OpenGL、libglut-dev等==</p><h2 id="二、下载PCL"><a href="#二、下载PCL" class="headerlink" title="二、下载PCL"></a>二、下载PCL</h2><p>源码在<a href="https://github.com/PointCloudLibrary/pcl.git%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%88%B0Home%E7%9B%AE%E5%BD%95">https://github.com/PointCloudLibrary/pcl.git，解压到Home目录</a></p><pre class=" language-c++"><code class="language-c++">git clone https://github.com/PointCloudLibrary/pcl.git</code></pre><h2 id="三、编译运行"><a href="#三、编译运行" class="headerlink" title="三、编译运行"></a>三、编译运行</h2><p>进入解压好的文件下，进行编译运行</p><pre class=" language-c++"><code class="language-c++">cd pclmkdir releasecd release</code></pre><p>使用默认选项运行 CMake 构建系统：</p><pre class=" language-c++"><code class="language-c++">cmake ..</code></pre><p>cmake 可能默认为调试版本。如果要使用增强的编译器优化来编译 PCL 的发布版本，可以用“-DCMAKE_BUILD_TYPE=Release”将构建目标更改为“Release”：</p><pre class=" language-c++"><code class="language-c++">cmake -DCMAKE_BUILD_TYPE=Release ..</code></pre><p>编译、安装</p><pre class=" language-c++"><code class="language-c++">make -j2sudo make -j2 install    </code></pre><p>==至此，PCL及其相关依赖库就已经安装好了，接下来进行测试==</p><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><p>cd到pcl/test 输入pcl_viewer car6.pcd<br>成功显示出两辆车即成功安装</p><img src="/2021/08/31/ji-yu-ubuntu18-04-an-zhuang-pcl/08/31/ji-yu-ubuntu18-04-an-zhuang-pcl/1.png" class=""><img src="/2021/08/31/ji-yu-ubuntu18-04-an-zhuang-pcl/08/31/ji-yu-ubuntu18-04-an-zhuang-pcl/2.png" class=""><p>大功告成！！！开心</p>]]></content>
      
      
      <categories>
          
          <category> 雷达点云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCL </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于鸿蒙的UI开发操作指南</title>
      <link href="2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/"/>
      <url>2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="基于鸿蒙的UI开发"><a href="#基于鸿蒙的UI开发" class="headerlink" title="基于鸿蒙的UI开发"></a>基于鸿蒙的UI开发</h1><blockquote><p>Ability是HarmonyOS应用程序的重要组成部分，分为FA（Feature Ability）和PA（Particle Ability）两种类型,进行HarmonyOS应用开发，首先要了解Ability如何使用:</p></blockquote><ul><li><strong>FA支持Page Ability</strong>：Page模板是FA唯一支持的模板，用于提供与用户交互的能力,==HarmonyOS提供了Java UI和JS UI两种UI框架==：Java UI提供了细粒度的UI编程接口，使应用开发更加灵活；JS UI提供了相对高层的UI描述，使应用开发更加简单。</li><li>PA支持Service Ability和Data Ability：Service模板用于提供后台运行任务的能力；Data模板用于对外部提供统一的数据访问抽象</li></ul><p>==<strong>本文以JS UI框架为例</strong>==</p><h2 id="JS-UI-框架"><a href="#JS-UI-框架" class="headerlink" title="JS UI 框架"></a>JS UI 框架</h2><p>==JS UI框架支持纯JavaScript、JavaScript和Java混合语言开发==</p><h3 id="一、JS-UI框架概述"><a href="#一、JS-UI框架概述" class="headerlink" title="一、JS UI框架概述"></a>一、JS UI框架概述</h3><p>JS UI框架是一种跨设备的高性能UI开发框架，支持声明式编程和跨设备多态UI,适用于手机（Phone）、平板（Tablet）、智慧屏（TV）和智能穿戴（Wearable）应用开发</p><p>==JS UI框架采用类HTML和CSS声明式编程语言作为页面布局和页面样式的开发语言==：</p><ul><li>.hml结尾的HML模板文件，这个文件用来描述当前页面的文件布局结构</li><li>.css结尾的CSS样式文件，这个文件用于描述页面样式</li><li>.js结尾的JS文件，这个文件用于处理页面和用户的交互</li></ul><p>==整体架构：==</p><p>JS UI框架包括应用层（Application）、前端框架层（Framework）、引擎层（Engine）和平台适配层（Porting Layer）</p><img src="/2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/1.png" class=""><ul><li><strong>应用层</strong>Application<strong>表示开发者使用JS UI框架开发的FA应用，这里的FA应用特指JS FA应用</strong></li><li>前端框架层Framework主要完成前端页面解析，页面路由机制和自定义组件等能力</li><li>引擎层Engine主要提供动画解析，渲染命令构建与绘制、事件管理等能力</li><li>适配层Porting Layer主要完成对平台层进行抽象，提供抽象接口，可以对接到系统平台。比如：事件对接、渲染管线对接和系统生命周期对接等</li></ul><h3 id="二、JS-FA应用开发目录及文件使用规则"><a href="#二、JS-FA应用开发目录及文件使用规则" class="headerlink" title="二、JS FA应用开发目录及文件使用规则"></a>二、JS FA应用开发目录及文件使用规则</h3><p>==JS FA指基于JavaScript或JavaScript和Java混合开发的FA==</p><h4 id="2-1-应用开发目录"><a href="#2-1-应用开发目录" class="headerlink" title="2.1 应用开发目录"></a>2.1 应用开发目录</h4><p>新建的JS工程目录如下：</p><img src="/2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/2.png" class=""><ul><li>==Java MainAbility== :该程序里的AceAbility类是JS FA在HarmonyOS上运行环境的基类，开发者应用的入口</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainAbility</span> <span class="token keyword">extends</span> <span class="token class-name">AceAbility</span> <span class="token punctuation">{</span>    @Override    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>应用通过AceAbility类中**setInstanceName()**接口设置该Ability的实例资源，并通过AceAbility窗口进行显示以及全局应用生命周期管理。</p><p><strong>setInstanceName</strong>(String name)的参数“name”指实例名称，实例名称与config.json文件中module.js.name的值对应。若开发者未修改实例名，而使用了缺省值default，则无需调用此接口。若开发者修改了实例名，则需在应用Ability实例的onStart()中调用此接口，并将参数“name”设置为修改后的实例名称。</p><p>使用方法为：在MainAbility的onStart()中的super.onStart()前调用此接口。以JSComponentName作为实例名称，代码示例如下</p><pre class=" language-js"><code class="language-js"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainAbility</span> <span class="token keyword">extends</span> <span class="token class-name">AceAbility</span> <span class="token punctuation">{</span>    @Override    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setInstanceName</span><span class="token punctuation">(</span><span class="token string">"JSComponentName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// config.json配置文件中module.js.name的标签值。</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><p>==common==:该文件夹下存放了一些公共资源文件，比如：媒体资源，自定义组件和JS文件</p></li><li><p>==componets==:存放一些自定义组件</p></li><li><p>==i18n==:存放了多语言的json文件，用于配置不同语言场景资源内容，比如：应用应用文本词条，图片路径等资源，注意 i18n 是开发保留文件夹，不可重命名</p><ul><li><strong>i18n &gt; en-US.json</strong>：此文件定义了在英文模式下页面显示的变量内容</li></ul><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"strings"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"hello"</span><span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span>    <span class="token string">"world"</span><span class="token punctuation">:</span> <span class="token string">"World"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>同理，zh-CN.json中定义了中文模式下的页面内容</strong></li></ul></li><li><p>==pages==:pages文件夹下存放多个==页面==，每个页面由hml、css和js文件组成==<strong>预览的时候需要点击任一个页面才可完成</strong>====我们需要的页面都可以写在这个文件夹下面==</p><ul><li><strong>index.hml</strong>：此文件定义了index页面的布局、index页面中用到的组件，以及这些组件的层级关系，例如：index.hml文件中包含了一个text组件，内容为“Hello World”文本。</li></ul><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>div <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token string">"container"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>text <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token string">"title"</span><span class="token operator">></span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token function">$t</span><span class="token punctuation">(</span><span class="token string">'strings.hello'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>text<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><ul><li> <strong>index.css：</strong>此文件定义了index页面的样式。例如：index.css文件定义了“container”和“title”的样式</li></ul><pre class=" language-js"><code class="language-js"><span class="token punctuation">.</span>container <span class="token punctuation">{</span>  flex<span class="token operator">-</span>direction<span class="token punctuation">:</span> column<span class="token punctuation">;</span>  justify<span class="token operator">-</span>content<span class="token punctuation">:</span> center<span class="token punctuation">;</span>  align<span class="token operator">-</span>items<span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span>title <span class="token punctuation">{</span>  font<span class="token operator">-</span>size<span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li> <strong>index.js：</strong>此文件定义了index页面的业务逻辑，比如数据绑定、事件处理等。例如：变量“title”赋值为字符串“World”</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    title<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">onInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$t</span><span class="token punctuation">(</span><span class="token string">'strings.world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre></li><li><p>==app.js==:文件用于全局js逻辑和应用声明周期管理</p></li><li><p>==<strong>resore config.json</strong>==：应用配置，用于描述应用的全局配置信息、在具体设备上的配置信息和HAP的配置信息(折叠起来了)</p><img src="/2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/3.png" class=""><p>主体文件分为app、device、module三个部分</p><ul><li><p>app:表示应用的全局配置信息</p></li><li><p>deviceConfig: 表示应用在具体设备上的配置信息</p></li><li><p>module 表示当前页面的配置信息，只对当前页面生效（==比如我们可以在deviceType里修改设备类型==）</p><pre class=" language-js"><code class="language-js"><span class="token string">"phone"</span><span class="token punctuation">,</span><span class="token string">"tv"</span><span class="token punctuation">,</span><span class="token string">"wearable"</span></code></pre></li></ul></li></ul><h4 id="2-2-文件使用规则"><a href="#2-2-文件使用规则" class="headerlink" title="2.2 文件使用规则"></a>2.2 文件使用规则</h4><h5 id="2-2-1-文件使用规则"><a href="#2-2-1-文件使用规则" class="headerlink" title="2.2.1 文件使用规则"></a>2.2.1 文件使用规则</h5><p>应用资源可通过绝对路径或相对路径的方式进行访问，本开发框架中绝对路径以 “/“ 开头，相对路径以 “./“ 或 “../“ ，具体访问规则如下：</p><ul><li>引用代码文件，需使用相对路径，比如：../common/xxx.js</li><li>引用资源文件，推荐使用绝对路径。比如：/common/xxx.png</li><li>公共代码文件和资源文件推荐放在 common 下，通过以上两条规则进行访问</li><li>CSS 样式文件中通过 url() 函数创建 数据类型，如：url(/common/xxx.png)</li><li>如果代码文件A和文件B位于同一目录，则代码文件B引用资源文件时可使用相对路径，也可使用绝对路径</li><li>如果代码文件A和文件B位于不同目录，则代码文件B引用资源文件时必须使用绝对路径。因为Webpack打包时，代码文件B的目录会发生变化</li><li>在js文件中通过数据绑定的方式指定资源文件路径时，必须使用绝对路径</li><li>==在使用DevEco Studio进行应用开发时，目录结构中的可选文件夹需要开发者根据实际情况自行创建==</li><li>pages页面文件名不能使用组件名称，比如：text.hml、button.hml等</li></ul><h5 id="2-2-2-媒体文件格式"><a href="#2-2-2-媒体文件格式" class="headerlink" title="2.2.2 媒体文件格式"></a>2.2.2 媒体文件格式</h5><table><thead><tr><th align="center">格式</th><th align="center">支持版本</th><th align="center">支持文件类型</th></tr></thead><tbody><tr><td align="center">BMP</td><td align="center">API Version 3</td><td align="center">.bmp</td></tr><tr><td align="center">JPEG</td><td align="center">API Version 3</td><td align="center">.jpg</td></tr><tr><td align="center">PNG</td><td align="center">API Version 3</td><td align="center">.png</td></tr></tbody></table><h5 id="2-2-3-app-js"><a href="#2-2-3-app-js" class="headerlink" title="2.2.3 app.js"></a>2.2.3 app.js</h5><p>标签中包含了实例名称、页面路由信息,每个应用可以在 app.js 自定义应用级生命周期的实现逻辑</p><ul><li>onCreate：在应用生成时被调用的生命周期函数</li><li>onDestory：在应用销毁时被调用的生命周期函数</li></ul><h3 id="三、构建用户界面"><a href="#三、构建用户界面" class="headerlink" title="三、构建用户界面"></a>三、构建用户界面</h3><h4 id="3-1-组件"><a href="#3-1-组件" class="headerlink" title="3.1 组件"></a>3.1 组件</h4><p>组件（Component）是构建页面的核心，每个组件通过对数据和方法的简单封装，实现独立的可视、可交互功能单元。组件之间相互独立，随取随用，也可以在需求相同的地方重复使用</p><p>根据组件的分类，可分为四大类</p><table><thead><tr><th align="center">组件类型</th><th align="center">主要组件</th></tr></thead><tbody><tr><td align="center">基础组件</td><td align="center">text、image、progress、rating、span、marquee、image-animator、divider、search、menu、chart</td></tr><tr><td align="center">容器组件</td><td align="center">div、list、list-item、stack、swiper、tabs、tab-bar、tab-content、list-item-group、refresh、dialog</td></tr><tr><td align="center">媒体组件</td><td align="center">video</td></tr><tr><td align="center">画布组件</td><td align="center">canvas</td></tr></tbody></table><p>==相关使用方法可查官方文档==</p><h6 id="组件具体步骤：（以chart组件为例）"><a href="#组件具体步骤：（以chart组件为例）" class="headerlink" title="组件具体步骤：（以chart组件为例）"></a>组件具体步骤：（以chart组件为例）</h6><ul><li>创建pages.chart文件夹，包含 .hml、.js、.css 三个文件，文件必须命名为 index，否则的话会出现预览错误。</li></ul><img src="/2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/4.png" class=""><ul><li>配置路由，在config.json这个文件中</li></ul><img src="/2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/5.png" class=""><ul><li>预览页面，注意打开当前需要预览的页面文件夹下 hml、css、js 任意一个文件</li></ul><img src="/2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/6.png" class=""><p><strong>注</strong>：组件里展示的图片需要开发者自行添加图片资源，放置到“js &gt; default &gt; common”目录下，common目录需自行创建</p><h4 id="3-2-构建布局"><a href="#3-2-构建布局" class="headerlink" title="3.2 构建布局"></a>3.2 构建布局</h4><ul><li><p>JS UI框架中，手机和智慧屏的基准宽度为720px（px为逻辑像素，非物理像素），实际显示效果会根据实际屏幕宽度进行缩放</p></li><li><p>JS UI 框架页面样式，系统基于 flex 弹性布局进行设置，默认就是 flex 弹性布局，需要注意，弹性布局会自动的拉升和压缩内部元素模块宽度、高度</p></li><li><p>其换算关系为：==组件的width设为100px时，在宽度为720物理像素的屏幕上，实际显示为100物理像素；在宽度为1440物理像素的屏幕上，实际显示为200物理像素==</p></li><li><p>==穿戴设备是一个圆形的表盘，需要针对圆形容器特征专门设计对应的样式==</p></li><li><p>==在 TV 上有一个黑色的背景，需要针对性的调整对应的 CSS 样式，颜色需要重点处理反转==</p></li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*    在phone 设备上1px = 3物理像素    在tv 设备上1px = 2物理像素    在穿戴设备上 1px = 2物理像素*/</span></code></pre><p>一个页面的基本元素包含标题区域、文本区域、图片区域等，每个基本元素内还可以包含多个子元素，开发者根据需求还可以添加按钮、开关、进度条等组件。在构建页面布局时，需要对每个基本元素思考以下几个问题：</p><ul><li>该元素的尺寸和排列位置</li><li>是否有重叠的元素</li><li>是否需要设置对齐、内间距或者边界</li><li>是否包含子元素及其排列位置</li><li>是否需要容器组件及其类型</li></ul><img src="/2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/7.png" class=""><h5 id="3-2-1-添加标题行和文本区域"><a href="#3-2-1-添加标题行和文本区域" class="headerlink" title="3.2.1 添加标题行和文本区域"></a>3.2.1 添加标题行和文本区域</h5><p>实现标题和文本区域最常用的是基础组件text。text组件用于展示文本，可以设置不同的属性和样式，文本内容需要写在标签内容区，完整属性和样式信息请参考官方文档，代码示例如下</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- xxx.hml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title-text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{headTitle}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>paragraph-text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{paragraphFirst}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>paragraph-text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{paragraphSecond}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* xxx.css */</span><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">30</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.title-text</span> </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#1a1a1a</span><span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.paragraph-text</span> </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#000000</span><span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">35</span>px<span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// xxx.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    headTitle<span class="token punctuation">:</span> <span class="token string">'Capture the Beauty in This Moment'</span><span class="token punctuation">,</span>    paragraphFirst<span class="token punctuation">:</span> <span class="token string">'Capture the beauty of light during the transition and fusion of ice and water. At the instant of movement and stillness, softness and rigidity, force and beauty, condensing moving moments.'</span><span class="token punctuation">,</span>    paragraphSecond<span class="token punctuation">:</span> <span class="token string">'Reflecting the purity of nature, the innovative design upgrades your visual entertainment and ergonomic comfort. Effortlessly capture what you see and let it speak for what you feel.'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><h5 id="3-2-2-添加图片区域"><a href="#3-2-2-添加图片区域" class="headerlink" title="3.2.2 添加图片区域"></a>3.2.2 添加图片区域</h5><p>添加图片区域通常用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-image-0000000000611597">image</a>组件来实现，使用的方法和text组件类似。图片资源建议放在“js &gt; default &gt; common”目录下，详细代码如下：</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- xxx.hml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{middleImage}}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">></span></span></code></pre><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* xxx.css */</span><span class="token selector"><span class="token class">.img</span> </span><span class="token punctuation">{</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">30</span>px<span class="token punctuation">;</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">30</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">385</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// xxx.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    middleImage<span class="token punctuation">:</span> <span class="token string">'/common/xxx.png'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><h5 id="3-2-3-添加容器"><a href="#3-2-3-添加容器" class="headerlink" title="3.2.3 ==添加容器=="></a>3.2.3 ==添加容器==</h5><p>要将页面的基本元素组装在一起，需要使用容器组件。在页面布局中常用到三种容器组件，分别是div、list和tabs。在页面结构相对简单时，可以直接用div作为容器，因为div作为单纯的布局容器，可以支持多种子组件，使用起来更为方便</p><p><strong>list组件</strong></p><p>当页面结构较为复杂时，如果使用div循环渲染，容易出现卡顿，因此推荐使用list组件代替div组件实现长列表布局，从而实现更加流畅的列表滚动体验。需要注意的是，list仅支持list-item作为子组件，具体的使用示例如下：</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- xxx.hml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list-item</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>listItem<span class="token punctuation">"</span></span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{textList}}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>desc-text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{$item.value}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list-item</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span></code></pre><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* xxx.css */</span><span class="token selector"><span class="token class">.desc-text</span> </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">683.3</span>px<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">35.4</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// xxx.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    textList<span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token punctuation">{</span>value<span class="token punctuation">:</span> <span class="token string">'JS FA'</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>示例中list中只包含一个list-item，list-item中只有一个text组件。在实际应用中可以在list中加入多个list-item，同时list-item下可以包含多个其他子组件</p><p><strong>Tabs组件</strong></p><p>当页面经常需要动态加载时，推荐使用tabs组件。tabs组件支持change事件，在页签切换后触发。tabs组件仅支持一个tab-bar和一个tab-content。具体的使用示例如下</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- xxx.hml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tabs</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tab-bar</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>Home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>Index<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>Detail<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tab-bar</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tab-content</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{homeImage}}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{indexImage}}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{detailImage}}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tab-content</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tabs</span><span class="token punctuation">></span></span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// xxx.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    homeImage<span class="token punctuation">:</span> <span class="token string">'/common/home.png'</span><span class="token punctuation">,</span>    indexImage<span class="token punctuation">:</span> <span class="token string">'/common/index.png'</span><span class="token punctuation">,</span>    detailImage<span class="token punctuation">:</span> <span class="token string">'/common/detail.png'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>tab-content组件用来展示页签的内容区，高度默认充满tabs剩余空间。tab-content支持scrollable属性,详见官网具体属性</p><h4 id="3-3-构建页面布局（-hml）"><a href="#3-3-构建页面布局（-hml）" class="headerlink" title="3.3 构建页面布局（.hml）"></a>3.3 构建页面布局（.hml）</h4><p>我们可以在pages文件夹下的index.hml文件中构建页面布局，这里注意不是 HTML，而是 HML，并且文件名也是 hml 结尾。因为鸿蒙的运行环境并不是浏览器，所以不支持原生的 html 标签，虽然有些标签名字一样，但那些只是鸿蒙为了便利开发者而定的，底层实现完全不一样，它们会转换成原生的鸿蒙控件，当然它也有特殊的 hml 标签，方便进行布局。语法上，除了一些 html 属性不支持外，其他都一样。这一点，跟 React Native 的原理是一样的。鸿蒙支持的标签可以查看 API 文档</p><p>在进行代码开发之前，首先要对页面布局进行分析，将页面分解为不同的部分，用容器组件来承载</p><ul><li>页面结构使用 HTML 相同的标签进行嵌套，最外层是 div 容器</li><li>文本内容放在<code>&lt;text&gt;</code>标签中才能呈现，否则不会呈现文本内容</li><li>可以直接调用鸿蒙JS封装好的组件，比如switch</li></ul><h4 id="3-4-构建页面样式（-css）"><a href="#3-4-构建页面样式（-css）" class="headerlink" title="3.4 构建页面样式（.css）"></a>3.4 构建页面样式（.css）</h4><p>鸿蒙中的 CSS 与普通的 CSS 还是有一些区别的，有些属性用法不同，并且不同的标签对于 CSS 属性的支持程度也不一样，可以参考 HML 部分中提到的 API 文档。在鸿蒙 TV 项目中，容器默认是 flex 布局，并且 flex-direction 为 row，行方向，这个需要注意一下<br>比如先给 text 标签设置默认的文本颜色，text 标签的 css 代码如下：</p><pre class=" language-css"><code class="language-css"><span class="token selector">text </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#414873</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其他的样式可以参考官方示例</p><ul><li>页面 CSS 支持 id、class、tag 选择器，建议使用 class 选择器</li><li>页面样式系统基于 flex 弹性布局进行设置，默认就是 flex 弹性布局，需要注意，弹性布局会自动的拉升和压缩内部元素模块宽度、高度</li><li>鸿蒙封装的 JS 组件，有一个专门的样式说明，这个和传统的 CSS 写法有很大的差异，这个尤其需要注意</li></ul><h4 id="3-5-构建页面逻辑（-js）"><a href="#3-5-构建页面逻辑（-js）" class="headerlink" title="3.5 构建页面逻辑（.js）"></a>3.5 构建页面逻辑（.js）</h4><p>可在pages里的index.js文件中构建页面逻辑，这里的语法和方式跟 Vue 一样</p><h4 id="3-6-页面路由"><a href="#3-6-页面路由" class="headerlink" title="3.6 页面路由"></a>3.6 页面路由</h4><p>很多应用由多个页面组成，比如用户可以从音乐列表页面点击歌曲，跳转到该歌曲的播放界面。开发者需要通过页面路由将这些页面串联起来，按需实现跳转。</p><p>页面路由router根据页面的uri来找到目标页面，从而实现跳转。以最基础的两个页面之间的跳转为例，具体实现步骤如下：</p><ul><li>在“Project”窗口，打开“entry &gt; src &gt; main &gt; js &gt; default”，右键点击“pages”文件夹，选择“New &gt; JS Page”，创建一个详情页</li><li>调用router.push()路由到详情页</li><li>调用router.back()回到首页</li></ul><h5 id="3-6-1-页面布局路由-hml"><a href="#3-6-1-页面布局路由-hml" class="headerlink" title="3.6.1 页面布局路由(hml)"></a>3.6.1 页面布局路由(hml)</h5><p>比如我们要在pages文件夹下构建index的detail这两个页面均包含一个text组件和button组件：text组件用来指明当前页面，button组件用来实现两个页面之间的相互跳转。hml文件代码示例如下</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- index.hml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>This is the index page.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>capsule<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Go to the second page<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>launch<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- detail.hml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>This is the detail page.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>capsule<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Go back<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>launch<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h5 id="3-6-2-页面样式路由-css"><a href="#3-6-2-页面样式路由-css" class="headerlink" title="3.6.2 页面样式路由(css)"></a>3.6.2 页面样式路由(css)</h5><p>构建index和detail页面的页面样式，text组件和button组件居中显示，两个组件之间间距为50px。css代码如下（两个页面样式代码一致）</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* index.css */</span><span class="token comment" spellcheck="true">/* detail.css */</span><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.title</span> </span><span class="token punctuation">{</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="3-6-3-实现页面跳转"><a href="#3-6-3-实现页面跳转" class="headerlink" title="3.6.3 实现页面跳转"></a>3.6.3 实现页面跳转</h5><p>为了使button组件的launch方法生效，需要在页面的js文件中实现跳转逻辑。调用router.push()接口将uri指定的页面添加到路由栈中，即跳转到uri指定的页面。在调用router方法之前，需要导入router模块。代码示例如下：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'@system.router'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">launch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    router<span class="token punctuation">.</span>push <span class="token punctuation">(</span><span class="token punctuation">{</span>      uri<span class="token punctuation">:</span> <span class="token string">'pages/detail/detail'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'@system.router'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">launch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    router<span class="token punctuation">.</span>push <span class="token punctuation">(</span><span class="token punctuation">{</span>      uri<span class="token punctuation">:</span> <span class="token string">'pages/detail/detail'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><img src="/2021/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/07/14/ji-yu-hong-meng-de-ui-kai-fa-cao-zuo-zhi-nan/8.png" class=""><h4 id="3-7-自定义组件使用"><a href="#3-7-自定义组件使用" class="headerlink" title="3.7 自定义组件使用"></a>3.7 自定义组件使用</h4><h5 id="3-7-1-自定义组件创建"><a href="#3-7-1-自定义组件创建" class="headerlink" title="3.7.1 自定义组件创建"></a>3.7.1 自定义组件创建</h5><p>JS UI框架支持自定义组件，用户可根据业务需求将已有的组件进行扩展，增加自定义的私有属性和事件，封装成新的组件，方便在工程中多次调用，提高页面布局代码的可读性：</p><ul><li>定义一个专门存放自定义组件的文件夹 components.tabbar 并设置3个基础文件 tabbar.hml、tabbar.js、tabbar.css，需要注意的是：3个文件的文件名必须保持一致，不然会存在找不到文件的情况。该自定义组件的目的是给页面底部配置一个 tabbar 选项卡体验</li><li>设置底部选项卡对应的 json 数据源，用来保存 icon 图片、标题，以及点击选中后的 icon 图片</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// common.datas.tabbarItem.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        img<span class="token punctuation">:</span><span class="token string">'common/images/home.png'</span><span class="token punctuation">,</span>        simg<span class="token punctuation">:</span><span class="token string">'common/images/home_s.png'</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span><span class="token string">'首页'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        img<span class="token punctuation">:</span><span class="token string">'common/images/hot.png'</span><span class="token punctuation">,</span>        simg<span class="token punctuation">:</span><span class="token string">'common/images/hot_s.png'</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span><span class="token string">'热点'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        img<span class="token punctuation">:</span><span class="token string">'common/images/us.png'</span><span class="token punctuation">,</span>        simg<span class="token punctuation">:</span><span class="token string">'common/images/us_s.png'</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span><span class="token string">'社区'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        img<span class="token punctuation">:</span><span class="token string">'common/images/me.png'</span><span class="token punctuation">,</span>        simg<span class="token punctuation">:</span><span class="token string">'common/images/me_s.png'</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span><span class="token string">'我'</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><ul><li>在tabbar.hml中使用 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-toolbar-0000001062209279">toolbar + toolbar-item</a> 内置组件构建底部 tabbar 选项卡服务</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>toolbar</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tabbar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>toolbar-item</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{tabbarItems}}<span class="token punctuation">"</span></span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>{{$item.img}}<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>{{$item.name}}<span class="token punctuation">'</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jump($idx)<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>toolbar-item</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>toolbar</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><ul><li>导入 tabbarItem 数据，并设置对应 data ，同时设置点击事件 动态设置点击对应 icon 选中</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> tabbarItems <span class="token keyword">from</span> <span class="token string">'../../common/datas/tabbarItem.js'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data<span class="token punctuation">:</span><span class="token punctuation">{</span>        tabbarItems    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">jump</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tabbarItems<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            item<span class="token punctuation">.</span>img <span class="token operator">=</span> tabbarItems<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>img<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tabbarItems<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>img <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tabbarItems<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>simg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>设置 CSS 样式 将 tabbar 选项卡置底「tabbar.css」</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.tabbar</span> </span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="3-7-2-自定义组件调用"><a href="#3-7-2-自定义组件调用" class="headerlink" title="3.7.2 自定义组件调用"></a>3.7.2 自定义组件调用</h5><p>自定义组件是用户根据业务需求，将已有的组件组合，封装成的新组件，可以在工程中多次调用，提高代码的可读性</p><p>自定义组件通过element引入到宿主页面，使用方法：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>comp<span class="token punctuation">'</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>../../components/tabbar/tabbar.hml<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>element</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        首页    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comp</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><ul><li>name 属性指自定义组件名称(非必填)，组件名称对大小写不敏感，默认使用小写，src 属性指自定义组件hml 文件路径(必填)，若没有设置 name 属性，则默认使用 hml 文件名作为组件名</li><li>事件绑定：自定义组件中绑定子组件事件使用 (on|@)child1 语法，子组件中通过 this.$emit(‘child1’, { params: ‘传递参数’ }) 触发事件并进行传值，父组件执行 bindParentVmMethod 方法并接收子组件传递的参数</li></ul>]]></content>
      
      
      <categories>
          
          <category> HarmonyOS UI开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HarmonyOS </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菜鸟程序员内功心法--C++（核心编程）</title>
      <link href="2021/06/25/c-xue-xi-2-0-he-xin-bian-cheng/"/>
      <url>2021/06/25/c-xue-xi-2-0-he-xin-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习-2-0-核心编程"><a href="#C-学习-2-0-核心编程" class="headerlink" title="C++学习-2.0_核心编程"></a>C++学习-2.0_核心编程</h1><p>主要针对面向对象编程技术，学习C++中的核心和精髓</p><h2 id="一、内存分区模型"><a href="#一、内存分区模型" class="headerlink" title="一、内存分区模型"></a>一、内存分区模型</h2><p>C++程序执行时，将内存大方向划分讷维4个区域</p><ul><li><p>代码区：存放函数体的二进制代码，由操作系统进行管理的</p></li><li><p>全局区：存放全局变量和静态变量一级常量</p></li><li><p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</p></li><li><p>堆区：由程序员分配和释放，若程序员不释放，释放结束时由操作系统收回</p></li></ul><p>内存四区意义：</p><ul><li>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</li></ul><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>在程序编译后，生成了可执行程序<code>.exe</code>，分为两个区域</p><p><strong>代码区</strong>：</p><ul><li><p>存放CPU执行的机器指令</p></li><li><p>代码区是共享的，共享的目的是在于对频繁被执行的程序，只需要在内存中有一份代码即可</p></li><li><p>代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令</p></li></ul><p><strong>全局区</strong>：</p><ul><li><p>全局变量和静态变量存放在此</p></li><li><p>全局区还包含了常量区，字符串常量和其他常量也存放在此</p><p>==该区域的数据在程序结束后由操作系统释放==</p></li></ul><p>==只要是局部变量（包含局部变量和*const修饰的局部变量)，都存放在局部区==</p><p>==全局变量、静态变量都存放在全局区，常量（包含字符串常量、<em>const修饰的变量</em>）离全局区很近==</p><ul><li>全局变量</li><li>静态变量</li><li>常量（<em>字符串常量</em>、<code>*const</code>修饰的变量<em>（<code>*const</code>修饰的全局变量</em>（全局常量）、<code>*const</code>修饰的局部变量*））</li><li>全局区（全局变量、静态变量、常量）</li><li>局部区（局部变量、<code>const</code>修饰的局部变量(局部常量））</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std; //全局变量int g_a = 10;int g_b = 10;//const修饰的全局变量叫全局常量const int c_g_a = 10;int main(){    //全局区    //全局变量、静态变量、常量    //创建一个普通的局部变量    int a = 10;    int b = 10;    cout << "局部变量a的地址为：" << (long long)&a << endl;    cout << "局部变量a的地址为：" << (long long)&b << endl;     cout << "全局变量g_a的地址为：" << (long long)&g_a << endl;    cout << "全局变量g_b的地址为：" << (long long)&g_b << endl;     //静态变量   在普通变量前面夹static,属于静态变量  放在全局区    static int s_a = 10;    static int s_b = 10;    cout << "静态变量s_b的地址为：" << (long long)&s_b << endl;     cout << "静态变量s_b的地址为：" << (long long)&s_b << endl;     //常量    //字符串常量(只要是双引号引起来的都叫字符串常量)    cout << "字符串常量的地址为：" << (long long)&"hello"<<endl;    //const修饰的变量    //const修饰的全局变量    cout << "全局常量c_g_a的地址为：" << (long long)&c_g_a << endl;    //const修饰的局部变量（局部常量）    const int c_L_a = 10; //c-const    g-global    l-local    cout << "const修饰的局部变量c_L_a的地址为：" << (long long)&c_L_a << endl;    system("pause");    return 0;}局部变量a的地址为：6487572局部变量a的地址为：6487576全局变量g_a的地址为：4206616全局变量g_b的地址为：4206612静态变量s_b的地址为：4206608静态变量s_b的地址为：4206608字符串常量的地址为：4210795全局常量c_g_a的地址为：4210876const修饰的局部变量c_L_a的地址为：6487580</code></pre><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区的特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放字符串常量和<code>const</code>修饰的全局变量(全局常量)</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p><strong>栈区</strong>：</p><p>由编译器自动分配释放，存放函数的参数值，局部变量等</p><p>notice:不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><ul><li>局部变量 （函数内的变量）存放在栈区，==栈区的数据在函数执行完后自动释放了==</li><li>形参数据也会放在栈区</li><li>不要返回局部变量的地址，你没有权限了</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//栈区数据的注意事项 ---不要返回局部变量的地址//扎努的数据由编译器管理开辟和释放int *func() //形参数据也会放在栈区{    int a = 10; //局部变量  存放在栈区，栈区的数据在函数执行完后自动释放了    return &a;  //返回局部变量的地址}int main(){    //接受func函数的返回值    int *p = func();    cout << *p << endl; //第一次可以打印正确数字，是因为编译器做了保留    cout << *p << endl; //第二次这个数据就不再保留了、内存不属于你了    system("pause");    return 0;}</code></pre><p><strong>堆区</strong>：</p><ul><li>由程序员释放，若程序员不释放，程序结束后由操作系统回收 </li><li>在C++中主要利用new在堆区开辟内存（是个地址）</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//P本身在栈区，但是P指向了堆区的地址，并且这个指向的地址被函数返回了，//接受这个返回值的指针变量也指向了堆区//P被释放了没有关系，但是NEW int(10)没有，所有根据P传回来的地址能找到10//10保存在了堆区，所以程序调用结束后并没有被释放int *func(){    //利用new关键字   可以将数据开辟到堆区    //指针  本质上也是局部变量，放在栈上，指针保存的数据是放在堆区    int *p = new int(10); //这玩意儿是个地址，要记住    return p;}//func函数中的P和main函数中的p不一样，func中的指针释放前把他的地址传给了int main(){    //在堆区开辟数据    int *p = func();    cout << *p << endl;    system("pause");    return 0;}</code></pre><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>C++中利用new操作符在堆区中开辟数据</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete</p><p><code>new 数据类型</code>  利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>局部变量由编译器自动释放，释放的时机是子函数调用结束</strong></p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//1、new的基本语法int *func(){    //在堆区创建数据    //new 返回的是  该数据类型的指针    int *p = new int(10);    return p;}void test01(){    int *p = func();    cout << *p << endl;    cout << *p << endl;    //堆区的数据由程序员管理释放，    //想释放yong delete    delete p;    // cout << *p << endl;//内存已经被释放了}//2、在堆区中利用new开辟数组void test02(){    //在堆区创建10整形数据的数组    int *arr = new int[10]; //10代表数组中由10个元素    for (int i = 0; i < 10; i++)    {        arr[i] = i + 10;//arr[i]=*(arr+i)    }    for (int i = 0; i < 10; i++)    {        cout << arr[i] << endl;    }    //释放堆区数组    //释放数组时，要加[]才可以    delete[] arr;}int main()    {        //test01();        test02();             system("pause");        return 0;    }</code></pre><h2 id="二、引用"><a href="#二、引用" class="headerlink" title="二、引用"></a>二、引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>给变量起别名</p><p>语法：<code>数据类型 &amp;别名 = 原名</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;int main(){    //引用的基本语法    //数据类型   &别名 = 原名    int a = 10;    int &b = a;    cout << "a=:" << a << endl;    cout << "b=:" << b << endl;    cout << "a的地址为：" << (long long)&a << endl;    cout << "b的地址为：" << (long long)&b << endl;    system("pause");    return 0;}</code></pre><h3 id="2-2-引用的注意事项"><a href="#2-2-引用的注意事项" class="headerlink" title="2.2 引用的注意事项"></a>2.2 引用的注意事项</h3><ul><li><p>引用必须初始化</p></li><li><p>引用在初始化后，不可以改变</p></li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;int main(){    int a = 10;        //1、引用必须初始化  //  int &b;//错误  ，必须初始化    int &b = a;    //2、引用一旦初始化就不可以改变了    int c = 20;    b = c;//赋值操作，而不是更改引用    cout << "a=: " << a << endl;    cout << "b=: " << b << endl;    cout << "c=: " << c << endl;    system("pause");    return 0;}</code></pre><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p><p>优点：可以简化指针修改实参</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//交换函数//1、值传递void test1(int a, int b){    int temp = a;    a = b;    b = temp;    cout << "a=:" << a << endl;    cout << "b=:" << b << endl;}//2、地址传递void test2(int *a, int *b){    int temp = *a;    *a = *b;    *b = temp;}//3、引用的方式传递void test3(int &a, int &b){    int temp = a;    a = b;    b = temp;}int main(){    int a = 20;    int b = 30;    //test1(a, b);//值传递，形参不会修饰实参    //test2(&a,&b);//地址传递，形参会修饰实参    test3(a, b); //引用传递也会修饰实参    cout << "a=:" << a << endl;    cout << "b=:" << b << endl;    system("pause");    return 0;}</code></pre><p>总结：通过引用参数产生的效果同按地址传递是一样的，引用的方法更清楚简单</p><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>引用是可以做为函数返回值存在的</p><p>注：不要返回局部变量引用</p><p>用法：函数调用作为左值</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//引用做函数返回值//1、不要返回局部变量引用int &test01(){    int a = 10; //局部变量存放在四区的栈区    return a;}//2、函数的调用可以作为左值int &test02(){    static int a = 10; //静态变量，存放在全局区，全局区上的数据在程序结束后系统释放    return a;}//函数调用作为左值int main(){    int &ref2 = test02();    cout << "ref2:" << ref2 << endl;    cout << "ref2:" << ref2 << endl;    test02() = 1000; //如果函数的返回值是引用，这个函数调用可以作为左值    cout << "ref2:" << ref2 << endl;    system("pause");    return 0;}</code></pre><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><ul><li>引用的本质是在C++内部的实现就是一个指针常量（==指针指向不可以修改，也就是说明为什么引用不能修改==）、</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//发现是引用，转换为 int * const ref = &a;void func(int &ref){    ref = 100; // ref是引用，转换为*ref = 100;}int main(){    int a = 10;    //自动转换为 int * const ref = &a;指针常量是指针指向不可以修改，也就是说明为什么引用不能修改    int &ref = a;    ref = 20; //内部发现ref是引用，自动转换为：*ref = 20    cout << "a = :" << a << endl;    cout << "ref = :" << ref << endl; //帮着解引用了*ref    system("pause");    return 0;}</code></pre><ul><li>C++推荐引用，因为语法方便，引用的本质是==指针常量==，但是所有的指针操作编译器都帮我们做了</li></ul><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加<code>const</code>修饰形参，防止形参改变实参</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;void showValue(const int &val){    //val = 30;//加入const 之后，就不可以修改了    cout << "val = " << val << endl;}int main(){    //常量引用    //使用场景，用来修饰形参，防止误操作    //int a = 10;    //int &b = 10; //引用必须引一块合法的内存空间    //加上const之后，比那一起将代码修改为：int temp = 10;const int &b = temp    //const int &b = 10;   // b = 20;//加入const之后变为只读，不可以修改    int a = 100;    showValue(a);    cout << "a = " << a << endl;    system("pause");    return 0;}</code></pre><h2 id="三、函数提高"><a href="#三、函数提高" class="headerlink" title="三、函数提高"></a>三、函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的</p><p>语法：<code>返回值类型   函数名   （参数 = 默认值）{}</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//函数的默认参数//如果我们传了数据，就用自己的数据，如果没有，那么用默认值//语法：返回值类型  函数名（形参 = 默认值）{}int add(int a, int b = 20, int c = 30){    return a + b + c;}//注意//1、如果某个位置已经有了默认参数，那么从这个值往后，从左到右都必须有默认值//2、如果函数的声明有了默认参数，那么函数的实现就不能有默认参数//声明和实现只能有一个默认参数int fun(int a = 10, int b = 20); //声明int fun(int a, int b)            //实现{    return a + b;}int main(){    cout << fun(1, 2) << endl;    system("pause");    return 0;}</code></pre><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来占位，调用函数时必须填补该位置</p><p>语法：<code>返回值类型   函数名  （数据类型）{}</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//占位参数//返回值类型 函数名（数据类型）{}void fun(int a, int) //占了个位置{    cout << "hello" << endl;}int main(){    fun(1, 1);    system("pause");    return 0;}</code></pre><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p>函数命名可以相同，提高复用性</p><p>函数重载满足条件：</p><ul><li><p>同一个作用域下</p></li><li><p>函数名称相同</p></li><li><p>函数参数类型不同或者个数不同或顺序不同</p></li></ul><p>注;函数的返回值不可以作为函数重载的条件</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//函数重载//可以让函数名相同，提高复用性//函数重载满足条件//1、同一个作用域下（不在main()函数里面，都是全局作用域）//2、函数名相同//3、函数参数类型不同或个数顺序不同void fun(){    cout << "这是fun()" << endl;}void fun(int a){    cout << "这是fun(int a)" << endl;}void fun(double a,int b){    cout << "这是fun(double a,int b)" << endl;}void fun(int a,double b){    cout << "这是fun(int a,double b)" << endl;}int main(){    fun(2.14,3);    system("pause");    return 0;}</code></pre><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li><p>引用作为重载条件</p></li><li><p>函数重载碰到函数默认参数</p></li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//函数重载的注意事项//1、引用作为重载的条件void fun(int &a){    cout << "fun()调用" << endl;}void fun(const int &a) //只读//const int &a = 10{    cout << "fun(const int &a)调用" << endl;}//2、函数重载碰到默认参数void func(int a, int b = 10){    cout << "fun（int a,int b = 10）" << endl;}void func(int a){    cout << "func（int a）" << endl;}int main(){    // int a = 10;    // fun(a);调用无const    //fun(10);调用有const    //func(10);//当函数重载碰到默认参数，出现二义性，报错，尽量避免这种情况    func(10, 20);    system("pause");    return 0;}</code></pre><h2 id="四、类和对象"><a href="#四、类和对象" class="headerlink" title="四、类和对象"></a>四、类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p>具有相同性质的对象，我们可以抽象为类，人属于人类，车属于车类</p><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的定义"><a href="#4-1-1-封装的定义" class="headerlink" title="4.1.1 封装的定义"></a>4.1.1 封装的定义</h4><p>封装时C++面向对象三大特性之一</p><p>意义：</p><ul><li><p>将属性和行为作为一个整体，表现生活中的事物</p></li><li><p>将属性和行为加以权限控制</p></li></ul><p>封装意义：</p><p>​    在设计类的时候，属性和行为写在一起，表现事物</p><p>语法：<code>class 类名{  访问权限：属性/行为 }；</code></p><p>设计一个圆类，求圆的周长</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;const double pi = 3.14; //最好用const 尽量少用define//设计一个圆类，求圆的周长//圆求周长的公式：2*pi*半径//class 代表设计一个类，类后面紧跟着的就是类名称class yuan{    //访问权限public:    //属性    int m_r;    //行为    //获取圆的周长    double zc()    {        return 2 * pi * m_r;    }};int main(){    //通过圆类创建一个具体的圆（对象）    //实例化（通过一个类，创建一个对象的的过程）    yuan c1;    //给对象的属性进行赋值操作    c1.m_r = 10;    cout << "圆的周长为：" << c1.zc() << endl;    system("pause");    return 0;}</code></pre><p>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><ul><li>类中的属性和行为 我们统称为成员</li><li>属性    也叫成员属性   成员变量</li><li>行为        成员函数      成员方法</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，//可以显示学生的姓名和学号//设计学生类class student{public: //公共权限    //属性    string name;    int num;    //行为    //显示姓名和学号    void show()    {        cout << "姓名：" << name << "学号：" << num << endl;    }    //给姓名赋值    void setname(string s)    {        name = s;    }    void setnum(int a)    {        num = a;    }};int main(){    //创建一个具体的学生 ，实例化对象    student s1 = {"王五", 11};    //给对象的属性进行赋值操作    // s1.name = "张三";    // s1.setname("张三");    // s1.num1 = 1111;    //显示学生信息    s1.show();    student s2;    // s2.name = "李四";    // s2.num = 1111;    s2.setname("张三");    s2.setnum(222);    s2.show();    system("pause");    return 0;}</code></pre><p>封装意义二：</p><p>类在设计师，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ul><li>public                公共权限</li><li>protected         保护权限</li><li>private              私有权限 </li></ul><p>类内是可以访问三个权限的，类外只能访问共有权限</p><h4 id="4-1-2-Struct和Class的区别"><a href="#4-1-2-Struct和Class的区别" class="headerlink" title="4.1.2 Struct和Class的区别"></a>4.1.2 Struct和Class的区别</h4><p>在C++中struct和class位于的区别在于默认的访问权限不同</p><ul><li>struct 默认权限为公共</li><li>class 默认权限为私有</li></ul><pre class=" language-c++"><code class="language-c++">#include <ctime>#include <iostream>#include <string>using namespace std;class c1{    int a; //默认权限是私有};struct c2{    int a; //默认权限为公有};int main(){    //c1 c1;    // c1.a = 10;//不可访问    c2 c2;    c2.a = 10;//可以访问    cout << c2.a << endl;    //Struct和Class的区别    //+ struct 默认权限为公共  pubilc    //+ class 默认权限为私有   private    system("pause");    return 0;}</code></pre><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><ul><li><p>将所有成员属性设置为私有，可以自己控制读写权限</p></li><li><p>对于写权限，我们可以检测数据的有效性</p></li><li><p>return;<em>//跳出函数</em></p></li><li><p>实际开发过程中需要设置数据的读写权限，所有需要区分公有私有</p></li></ul><pre class=" language-c++"><code class="language-c++">#include <ctime>#include <iostream>#include <string>using namespace std;//成员属性设置为私有//1、将所有成员属性设置为私有，可以自己控制读写权限//2、对于写权限，我们可以检测数据的有效性//class Person{public:    //写姓名    //可读可写    void setname(string n)    {        name = n;    }    //获取姓名    string getname() //    {        //类内可以操作        // age = 19;//初始化年龄        return name;    }    //获取年龄    int getage()    {   //类内可以操作        // age = 19;//初始化年龄        return age;    }    //设置年龄   可以判断一下    void setage(int a)    {        if (a < 0 || a > 150)        {            cout << "妖精,别跑！" << endl;            return; //跳出函数        }        age = a;    }    //写入女朋友    //只写    void setgirlfriden(string girl)    {        girlfriden = girl;    }private:    //姓名  可读可写    string name;    //年龄  只读    int age;    //女朋友  只写    string girlfriden;};int main(){    Person p;    p.setname("张三"); //可读可写    cout << "姓名：" << p.getname() << endl;    p.setage(21);    cout << "年龄：" << p.getage() << endl; //只读    p.setgirlfriden("小仓");    system("pause");    return 0;}</code></pre><h4 id="案例1：设计立方体类"><a href="#案例1：设计立方体类" class="headerlink" title="案例1：设计立方体类"></a>案例1：设计立方体类</h4><p>设计立方体类</p><ul><li>求出立方体的面积和体积</li><li>分别用全局函数和成员函数判断两立方体是否相等</li></ul><p>==成员的属性都尽量设置为私有==</p><pre class=" language-c++"><code class="language-c++">#include <ctime>#include <iostream>#include <string>using namespace std;//立方体设计//1、创建立方体类//2、设计属性//3、设计行为   获取立方体的面积和体积//4、分别用全局函数和成员函数(写在类里面)判断两个立方体是否相等class cube{public:    //行为//成员函数一般为公有    void setcube(int l, int w, int h)    {        m_l = l;        m_w = w;        m_h = h;    }    //获取面积    int s()    {        int s = 0;        s = 2 * (m_l * m_w + m_l * m_h + m_w * m_h);        return s;    }    //获取体积    int v()    {        int v = 0;        v = m_l * m_w * m_h;        return v;    }    //利用成员函数判断两个立方体是否相等    bool pdbyclass(cube &c) //传一个参数就行    {        if ((s() == c.s()) && (v() == c.v()))        {            return true;        }        else        {            return false;        }    }private:    //成员属性一般设置为私有    int m_l;    int m_w;    int m_h;};//利用全局函数判断两个立方体是否相等//引用方式bool panduan(cube &c1, cube &c2) //用引用的方式不会占太多内存了{    if ((c1.s() == c2.s()) && (c1.v() == c2.v()))    {        return true;    }    else    {        return false;    }}//指针方式// bool panduan(cube *c1, cube *c2) //用引用的方式不会占太多内存了// {//     if ((c1->s() == c2->s()) && (c1->v() == c2->v()))//     {//         return true;//     }//     else//     {//         return false;//     }// }int main(){    cube c1;    c1.setcube(10, 10, 10);    cout << c1.s() << endl;    cout << c1.v() << endl;    cube c2;    c2.setcube(10, 10, 12);    cout << c2.s() << endl;    cout << c2.v() << endl;    //全局函数判断    bool ref1 = panduan(c1, c2);    if (ref1)    {        cout << "c1和c2是相等的" << endl;    }    else    {        cout << "c1和c2是不相等的" << endl;    }    //成员函数判断    bool ref2 = c1.pdbyclass(c2);    if (ref2)    {        cout << "c1和c2是相等的" << endl;    }    else    {        cout << "c1和c2是不相等的" << endl;    }    //cout << panduan(&c1, &c2);//指针方式    system("pause");    return 0;}</code></pre><h4 id="案例2：点和圆的关系"><a href="#案例2：点和圆的关系" class="headerlink" title="案例2：点和圆的关系"></a>案例2：点和圆的关系</h4><p>设计一个圆形类和一个点类，计算点和圆的关系</p><p><img src="/2021/06/25/c-xue-xi-2-0-he-xin-bian-cheng/Users\X_Bruce\AppData\Roaming\Typora\typora-user-images\image-20210513165117849.png" alt="image-20210513165117849"></p><ul><li><p>在一个类中可以让另一个类做本类的成员private:</p><p>  int m_r;    <em>//半径</em></p><p>  Point m_center; <em>//圆心</em></p></li></ul><pre class=" language-c++"><code class="language-c++">#include <ctime>#include <iostream>#include <string>using namespace std;//点和圆的关系的案例//点类class Point{public:    //设置x坐标    void setx(int x)    {        m_x = x;    }    //获取x坐标    int getx()    {        return m_x;    }    //设置y坐标    void sety(int y)    {        m_y = y;    }    //获取y坐标    int gety()    {        return m_y;    }private:    int m_x; //横坐标    int m_y; //纵坐标};//圆类class yuan{public:    //设置半径    void setr(int r)    {        m_r = r;    }    //获取半径    int getr()    {        return m_r;    }    //设置圆心    void setcenter(Point center)    {        m_center = center;    }    //获取圆心    Point getcenter()    {        return m_center;    }private:    int m_r;        //半径    Point m_center; //圆心};//全局函数判断点和圆的关系void relation(yuan &c, Point &o){    //计算两点之间的距离的平方    int destance = (c.getcenter().getx() - o.getx()) * (c.getcenter().getx() - o.getx()) + (c.getcenter().gety() - o.gety()) * (c.getcenter().gety() - o.gety());    //计算半径的平方    int rdestance = c.getr() * c.getr();    //判断关系    if (destance > rdestance)    {        cout << "点在圆外" << endl;    }    else if (destance == rdestance)    {        cout << "点在圆上" << endl;    }    else    {        cout << "点在圆内" << endl;    }}int main(){    //创建圆    yuan c1;    c1.setr(10);    Point center;    center.setx(10);    center.sety(0);    c1.setcenter(center);    //创建点    Point p;    p.setx(10);    p.sety(10);    //判断关系    relation(c1, p);    system("pause");    return 0;}</code></pre><ul><li>分文件编写：头文件中写声明，源文件中写实现</li><li>头文件与源文件的名称不一定相同，但源文件要记得加头文件声明</li></ul><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li>C++中的面向对象来源于生活，每个对象也都会有初始设置一级对象销毁前的清理数据的设置</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的初始化和清理也是两个非常重要的安全问题</p><ul><li><p>一个对象或者变量没有初始状态，对其使用后果是未知的</p></li><li><p>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p></li></ul><p>C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作，对象的初始化和清理工作是编译器强制要求我们做的事情，因此我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数都是空实现</p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用</li><li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作</li></ul><p><strong>构造函数语法</strong>；<code>类名（）{}</code></p><ul><li><p>构造函数，没有返回值也不写void</p></li><li><p>函数名与类名相同</p></li><li><p>构造函数可以有参数，因此可以发送重载</p></li><li><p>程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次</p></li></ul><p><strong>析构函数语法</strong>：<code>~类名（）{}</code></p><ul><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同，在名称前加上符号~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用硒鼓，无需手动调用，而且只会调用一次</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//对象的初始化和清理//1、构造函数进行初始化操作class Person{public:    //1、构造函数，没有返回值也不写void    //2、函数名与类名相同    //3、构造函数可以有参数，因此可以发送重载    //4、程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次    Person()    {        cout << "Person构造函数的调用" << endl;    }    //2、析构函数进行清理工作    //1、析构函数，没有返回值也不写void    //2、函数名称与类名相同，在名称前加上符号~    //3、析构函数不可以有参数，因此不可以发生重载    //4、程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次    ~Person()    {        cout << "Person析构函数的调用" << endl;    }};//构造和析构都是必须有的函数，如果我们自己 不提供，编译器会提供一个空实现的构造和析构void test01(){    Person p; //局部变量在栈上的数据，test01执行完毕后，释放这个对象}int main(){    // test01();    Person p;        //结束之后只有构造没有析构了   此时的p仍然在栈区                     //只有new或malloc才会在堆区    system("pause"); //main()函数执行完，变量销毁完才会执行析构，在这一行中断了    return 0;}</code></pre><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种方式分类：</p><p>​    按参数分为：有参构造和无参构造</p><p>​    按类型分为：普通构造和拷贝构造</p><p>三种调用方式：</p><p>​    括号法</p><p>​    显示法</p><p>​    隐式转换法</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//1、构造函数的分类//分类// 按照参数分类      无参构造(默认构造)和有参构造// 按照类型分类      普通构造函数和拷贝构造函数class Person{public:    //构造函数    Person() //无参    {        cout << "Person无参构造函数的调用" << endl;    }    Person(int a) //有参    {        age = a;        cout << "Person有参构造函数的调用" << endl;    }    //拷贝构造函数    Person(const Person &p) //先记住这种写法  常量引用又是指针常量，前面在加一个const就是常量指针常量    {        //将传入的人身上的所有的属性，拷贝到当前的函数身上        age = p.age;        cout << "Person拷贝构造函数的调用" << endl;    }    ~Person()    {        cout << "Person析构函数的调用" << endl;    }    int age;};void test01() //创建一个对象就会调用一次，创建两个对象就会调用两次{    //1、括号法    // Person p1;//默认构造函数调用    // Person p2(10);//有参函数的调用    // Person p3(p2); //拷贝构造函数构造    //注意事项1    //调用默认构造函数时，不要加（）    //因为下面这行代码，编译器会认为是一个函数的声明，不会认为在创建对象    //Person p1();    // cout << "p2的年龄为：" << p2.age << endl;    //cout << "p3的年龄为：" << p3.age << endl;    //2、显示法    Person p1;    Person p2 = Person(10); //有参构造    Person p3 = Person(p2); //拷贝构造    //Person(10);     //匿名对象  特点：当前行执行结束后，系统会立即回收掉匿名对象    //注意事项2    //不要利用拷贝构造函数   初始化匿名对象   编译器任务Person(p3)===Person p3:对象声明    //Person(P3);    //3、隐式转换法    Person p4 = 10; //相当于写了Person p4 = person(10);有参构造的调用    Person p5 = p4; //拷贝构造}int main(){    test01();    // Person s;    system("pause");    return 0;}</code></pre><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li><p>使用一个已经创建完毕的对象来初始化一个新对象</p></li><li><p>值传递的方式给函数参数传值</p></li><li><p>以值方式返回局部对象</p></li></ul><p>当函数的返回值是类对象时，系统自动调用拷贝构造函数（会有编译器可能会进行优化）</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//拷贝构造函数调用时间class Person{public:    Person()    {        cout << "Person构造函数的调用" << endl;    }    Person(int age)    {        m_age = age;        cout << "Person有参构造函数的调用" << endl;    }    Person(const Person &p)    {        m_age = p.m_age;        cout << "Person拷贝构造函数的调用" << endl;    }    ~Person()    {        cout << "Person析构函数的调用" << endl;    }    int m_age;};//1、使用一个基于创建完毕的对象来车初始化一个新对象void test01(){    Person p1(20);    Person p2(p1);    cout << "p2的年龄为：" << p2.m_age << endl;}//2、值传递的方式给函数参数传值void dowork(Person p) //{}void test02(){    Person p;    dowork(p);}//3、值方式返回局部对象Person dowork2(){    Person p1;    return p1;}void test03(){    Person p = dowork2();}int main(){    // Person p;    //test01();    //test02();    test03();    system("pause");    return 0;}</code></pre><h4 id="4-2-4-构造函数的调用规则"><a href="#4-2-4-构造函数的调用规则" class="headerlink" title="4.2.4 构造函数的调用规则"></a>4.2.4 构造函数的调用规则</h4><p>默认情况下，C++编译器至少给一个类添加3个函数</p><ul><li><p>默认构造函数（无参，函数体为空）</p></li><li><p>默认析构函数（无参，函数体为空）</p></li><li><p>默认拷贝函数，对属性进行值拷贝</p></li></ul><p>构造函数调用规则：</p><ul><li>如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//构造函数的调用规则//1、创建一个类，C++编译器会给每个类都添加至少3个函数//默认构造（空实现）//析构函数 （空实现）//拷贝构造 （值拷贝）//2、如果我们写了有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造//如果我们写了拷贝构造函数，编译器就不提供其他了class Person{public:    // Person()    // {    //     cout << " Person的默认构造函数调用" << endl;    // }    Person(int a)    {        age = a;        cout << " Person的有参构造函数调用：" << age << endl;    }    // Person(const Person &p)    // {    //     age = p.age;    //     cout << "Person的拷贝构造函数调用" << endl;    // }    ~Person()    {        cout << "Person的析构函数调用" << endl;    }    int age;};// void test01()// {//     Person p;//     p.age = 18;//     Person p2(p);//编译器做了值拷贝x//     cout << "p2的年龄为：" << p2.age << endl;// }void test02(){    Person p(28);    Person p2(p);}int main(){    // Person p1;    // test01();    test02();    system("pause");    return 0;}</code></pre><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>浅拷贝带来的问题</strong>：堆区的内存重复释放，要用深拷贝去解决</p><p><img src="/2021/06/25/c-xue-xi-2-0-he-xin-bian-cheng/Users\X_Bruce\AppData\Roaming\Typora\typora-user-images\image-20210517181016917.png" alt="image-20210517181016917"></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//深拷贝与浅拷贝class Person{public:    Person()    {        cout << " Person的默认构造函数调用" << endl;    }    Person(int a, int height)    {        age = a;        //堆区的数据，由程序员手动开辟，也由其手动释放        m_height = new int(height); //创建堆区的数据  返回该数据类型的指针        cout << " Person的有参构造函数调用：" << age << endl;    }    //自己实现拷贝构造函数，解决浅拷贝带来的问题    Person(const Person &p)    {        cout << "拷贝构造函数调用" << endl;        age = p.age;        //m_height = p.m_height;编译器默认实现就是这行代码        //深拷贝操作        m_height = new int(*p.m_height);    }    ~Person()    {        //析构代码，将堆区开辟的数据做释放操作        if (m_height != NULL)        {            delete m_height;            m_height = NULL;        }        cout << "Person的析构函数调用" << endl;    }    int age;    int *m_height;};void test01() //栈的释放规则，先进后出{    Person p1(19, 185);    cout << "p1的年龄为：" << p1.age << "身高为：" << *p1.m_height << endl;    Person p2(p1);    cout << "p2的年龄为：" << p2.age << "身高为：" << *p2.m_height << endl;}int main(){    test01();    system("pause");    return 0;}</code></pre><p>==如果属性有在堆区开辟的，一定要提供自己的拷贝构造函数，防止浅拷贝带来的问题==</p><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p>C++提供了初始化 列表语法，用来初始化属性</p><p><code>构造函数（）:属性1（值1），属性2（值2）...{}</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//初始化列表class Person{public:    //传统初始化    // Person(int a,int b,int c)//构造函数    // {    //     m_a = a;    //     m_b = b;    //     m_c = c;    // }    //初始化列表初始化属性1    // Person() : m_a(10), m_b(10), m_c(10)    // {    // }    //初始化列表方法2    Person(int a, int b, int c) : m_a(a), m_b(b), m_c(c)    {    }    //属性    int m_a;    int m_b;    int m_c;};void test01(){    //Person p(10, 20, 30);    Person p(2, 5, 8);    cout << "m_a=" << p.m_a << endl;    cout << "m_b=" << p.m_b << endl;    cout << "m_c=" << p.m_c << endl;}int main(){    test01();    system("pause");    return 0;}</code></pre><h4 id="4-2-7-类和对象作为类成员"><a href="#4-2-7-类和对象作为类成员" class="headerlink" title="4.2.7 类和对象作为类成员"></a>4.2.7 类和对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员</p><pre class=" language-c++"><code class="language-c++">class A()class B{    A a;}</code></pre><p>B类中有对象A作为成员，A为对象成员</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//类对象作为类成员//手机类class Phone{public:    //机型    Phone(string pname) //手机类的构造函数    {        cout << "手机的构造函数调用" << endl;        p_name = pname;    }    //手机品牌名称    string p_name;};//人类class Person{public:    //Phone m_phone = pname;   隐式转换法    Person(string name, string pname) : m_name(name), m_phone(pname) //人类的构造函数+初始化列表    {        cout << "人类的构造函数调用" << endl;    }    //姓名    string m_name;    //手机    Phone m_phone;};void test01(){    Person p("王五", "苹果max");    cout << "姓名：" << p.m_name << "机型：" << p.m_phone.p_name << endl;}int main(){    test01();    system("pause");    return 0;}手机的构造函数调用人类的构造函数调用姓名：王五机型：苹果max请按任意键继续. . .    手机的构造函数调用人类的构造函数调用姓名：王五机型：苹果max人类的析构函数调用手机类的析构函数调用请按任意键继续. . .</code></pre><ul><li>先调用了手机类构造函数，然后调用了人类构造函数</li><li>当其他的类的对象作为本类的成员时，先构造类对象，在构造自身，</li><li>析构的顺序和构造的顺序相反</li></ul><h4 id="4-2-8-静态成员函数"><a href="#4-2-8-静态成员函数" class="headerlink" title="4.2.8 静态成员函数"></a>4.2.8 静态成员函数</h4><p>静态成员就是在成员变量和成员函数前面加上关键字static，称为静态成员，静态成员分为：</p><ul><li><p>静态成员变量</p><ul><li><p>所有对象共享同一份数据</p></li><li><p>在编译阶段分配内存</p></li><li><p>类内声明，类外初始化</p></li></ul></li><li><p>静态成员函数</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>：：是作用域运算符//类名访问静态成员的方法</p><ul><li>初始化和定义的区别：<ul><li>初始化时赋一个初值，而定义是在分配内存，声明只是表明了变量的数据类型和属性，并不分配内存，定义是要分配内存的</li></ul></li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//静态成员函数//所有对象共享同一个函数//静态成员函数只能访问静态成员变量class Person{public:    //静态成员函数    static void func()    {        m_a = 100; //静态函数可以访问静态成员变量                   // m_b= 200；//静态成员函数不可以访问非静态成员变量，无法区分到底是哪个对象的m_b属性        cout << "static void func函数的调用" << endl;    }    static int m_a; //静态成员变量  必须在类内声明类外初始化一下    int m_b;        //非静态成员变量    //静态成员函数也是有访问权限的private:    static void func2()    {        cout << "static void func2函数的调用" << endl;    }};int Person::m_a = 0; //类外初始化//有两种访问方式void test01(){    //1、通过对象来访问    Person p;    p.func();    //2、通过类名来访问    Person::func();    // Person::func2();//类外访问不到私有静态成员函数}int main(){    test01();    system("pause");    return 0;}</code></pre><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开储存"><a href="#4-3-1-成员变量和成员函数分开储存" class="headerlink" title="4.3.1 成员变量和成员函数分开储存"></a>4.3.1 成员变量和成员函数分开储存</h4><p>在C++中，类内成员变量和成员函数分开储存</p><p>只有非静态变量才属于类的对象</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//成员变量和成员函数分开存储class Person{    int m_a = 10;          //非静态成员变量   //属于类的对象上面的    static int m_b;        //静态成员变量，类内声明，类外初始化//不属于类的对象上    void fun(){};          //非静态成员函数  不属于类的对象上    static void func2(){}; //静态成员函数  不属于类的对象上};int Person::m_b = 10; //类外初始化void test01(){    Person p;    //空对象占用的内存空间为： 1    //C++编译器会给每个空对象也分配一个字节空间，为了区分空对象占的内存的位置    //每一个空对象，都应该有一个独一无二的内存地址    cout << "size of p = " << sizeof(p) << endl;}void test02(){    Person p;    //非静态成员变量对象占用的内存空间为： 4    cout << "size of p = " << sizeof(p) << endl;    //cout << "int m_a = " << p.m_a << endl;}int main(){    //test01();    test02();    system("pause");    return 0;}</code></pre><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>在C++中，类内成员变量和成员函数分开储存</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会用一块代码，那么问题是：这一块代码是如何区分调用自己的那个对象是哪个呢？</p><p>C++通过提供特殊的对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象</p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li><p>当形参和成员变量同名时，可以使用this指针来区分</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用return *this</p></li></ul><p>==要理解重点==：链式编程思想，函数的返回值要用引用</p><p><strong>若返回的是一个值的话，相当于创建了个person p3 =p2,浅拷贝了一个p3,下面的运算是p3加10,而不是p2了</strong></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class Person{    // public:    //     Person(int age )//构造函数  //形参和实参（成员对象）不能混淆    //     {    //         age = age;    //     }    //     int age;public:    Person(int age) //(有参构造)构造函数  //形参和实参（成员对象）不能混淆    {        //this指针指向的是被调用的成员函数所属的对象  指向的对象是p1;        this->age = age;    }    Person &Personaddage(Person &p) //该函数返回的不是指针或者引用，因为前面加了*所以返回的是p2的本体                                    //引用指向本身内存，不用引用就是拷贝了，                                    //加引用返回的是person类型的对象，而加引用返回的是p2本身；                                    //不引用就会通过拷贝构造创建新对象，之后的所有的操作都相当于是在对新对象进行操作，p2就不会改变了                                    //叠加实在原数据改变的基础上递增，所以用引用，引用时地址传递，会改变原有的值，不用引用就不会改变原有的值，就是复制操作了                                    //防止拷贝构造    {        this->age += p.age;        //this指向p2的指针，而*this指向的就是p2这个对象本体        return *this;    }    int age;};//1、解决名称冲突void test01(){    Person p1(18);    cout << "person的年龄为：" << p1.age << endl;}//2、返回对象本身用 * thisvoid test02(){    Person p1(10);    Person p2(10);    //若可以返回p2本身，则就可以一直执行加的操作    //链式编程思想    p2.Personaddage(p1).Personaddage(p1);    cout << "p2的年龄为：" << p2.age << endl;}int main(){    //test01();    test02();    system("pause");    return 0;}</code></pre><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><ul><li>代码的健壮性值得是自己的代码在不影响逻辑的情况下不存在崩溃的问题</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//空指针调用成员函数class Person{public:    void showclassname()    {        cout << "this is person class" << endl;    }    void showpersonage()    {        //报错原因是传入的指针为null        if (this == NULL)        {            return;        }        cout << "age = " << this->m_age << endl; //空指针不能访问成员数据    }    int m_age;};void test01(){    Person *p = NULL;    p->showclassname();    p->showpersonage();}int main(){    test01();    system("pause");    return 0;}</code></pre><h4 id="4-3-4-const修饰成员函数（限定了只读状态）"><a href="#4-3-4-const修饰成员函数（限定了只读状态）" class="headerlink" title="4.3.4 const修饰成员函数（限定了只读状态）"></a>4.3.4 const修饰成员函数（限定了只读状态）</h4><p>常函数：</p><ul><li><p>成员函数后加const后我们称为这个函数为常函数</p></li><li><p>常函数内不可以修改成员属性</p></li><li><p>成员属性声明时加关键字mutable后，在常函数中依然可以修改</p></li></ul><p>常对象：</p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><em>this指针的本质  是指针常量  指针的指向是不可以修改的</em></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//常函数class Person{public:    //this指针的本质   是指针常量   指针的指向是不可以修改的    //const Person * const this;    //在成员函数后加const ,修饰的是this指针，让指针指向的值也不可以修改    void showPerson() const    {        //this->m_a = 100;        // this = NULL;//this指针是不可以修改指针的指向的    }    void fun()    {    }    int m_a;    mutable int m_b; //特殊变量，即使在常函数中，也可以修改这个值,加上关键字mutable};void test01(){    Person p;    p.showPerson();}//常对象void test02(){    const Person p; //在对象前加上const ,变成常对象    //p.m_a = 100;    p.m_b = 100; //m_b是特殊值，在长对象下也可以修改    //常对象只能调用常函数    p.showPerson();    //p.fun();常对象不可以调用普通成员函数，因为普通成员函数可以修改属性}int main(){    system("pause");    return 0;}</code></pre><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>打个比方，你家有客厅(public)，也有你的卧室(private)</p><p>客厅允许所有的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的好朋友一起进去</p><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类访问另一个类中私有成员</p><p>友元的关键字为==friend==</p><p>友元的三种实现</p><ul><li><p>全局函数做友元</p></li><li><p>类做友元</p></li><li><p>成员函数做友元</p></li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a><strong>4.4.1 全局函数做友元</strong></h4><p><code>friend void goodguy(building *building);</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;#include <string>//建筑物的类class building{    //goodgay全局函数是building好朋友，可以访问building中私有成员    friend void goodguy(building *building);public:    building() //构造函数，赋初值    {        m_sittingroom = "客厅";        m_bedroom = "卧室";    }    string m_sittingroom; //客厅private:    string m_bedroom; //卧室};//全局函数void goodguy(building *building){    cout << "好朋友的全局函数  正在访问：" << building->m_sittingroom << endl;    cout << "好朋友的全局函数  正在访问：" << building->m_bedroom << endl; //私有属性不能访问}void test01(){    building building;    goodguy(&building);}int main(){    test01();    system("pause");    return 0;}</code></pre><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a><strong>4.4.2 类做友元</strong></h4><p>==类内声明，类外实现（要加作用域）==</p><p><code>friend class goodguy;</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//类做友元class Building; //函数的声明class goodguy{public:    goodguy();    //goodguy类的构造函数    void visit(); //参观函数，访问Building中的属性    Building *building;};class Building{    friend class goodguy;//关键点public:    Building();           //Building类的构造函数    string m_sittingroom; //客厅private:    string m_bedroom; //卧室};//类外写成员函数//普通成员函数，类外定义返回值类型后面写作用域//类内做声明，类外做函数的实现Building::Building() //加一个作用域{    m_sittingroom = "客厅";    m_bedroom = "卧室";}goodguy::goodguy() //加一个作用域{    //创建一个建筑物对象    //因为在goodguy类内定义了一个Building类型的指针，因此在类外写构造函数的时候采用new创建一个地址并用building接受，保证和类内所写的内容一致    //new  到堆区，要不然就在栈区，用完就是释放了    building = new Building;}void goodguy::visit() //这是goodguy下面的visit函数{    cout << "好基友这个类正在访问：" << building->m_sittingroom << endl;    cout << "好基友这个类正在访问：" << building->m_bedroom << endl;}void test01(){    //先调用goodguy里的构造函数，然后也会调用building里的构造函数    goodguy gg;    gg.visit(); //访问building里面维护的sittingroom}int main(){    test01();    system("pause");    return 0;}</code></pre><p>####<strong>4.4.3 成员函数做友元</strong></p><p><code>friend void goodguy::visit();</code></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;#include <string>class Building; //前置声明class goodguy{public:    goodguy();    void visit();  //让visit函数可以访问building类中的私成员    void visit2(); //让visit2函数不可以访问building类中的私成员    //Building本来就不属于goodguy，需要通过一个指针来找到Building,然后再堆里新开辟空间了    Building *building; //前置声明没有实现，要访问对象只能用指针，不能使用对象};class Building{    //friend void visit();//告诉是全局函数    friend void goodguy::visit(); //告诉是goodguy下的visit成员函数作为本类中的好朋友，可以访问私有成员public:    //养成习惯，所有的函数都写到类外实现    Building();           //构造函数，函数名要和类名一致    string m_sittingroom; //客厅private:    string m_bedroom; //卧室};//类外实现成员函数Building::Building() //构造函数赋初值{    m_sittingroom = "客厅";    m_bedroom = "卧室";}goodguy::goodguy(){    building = new Building; //用building指针维护Building建筑物这个对象}void goodguy::visit() //让visit函数可以访问building类中的私成员{    cout << "visit 函数正在访问:" << building->m_sittingroom << endl;    cout << "visit 函数正在访问:" << building->m_bedroom << endl;}void goodguy::visit2() //让visit2函数不可以访问building类中的私成员{    cout << "visit 函数正在访问:" << building->m_sittingroom << endl;    // cout << "visit 函数正在访问:" << building->m_bedroom << endl;}void test01(){    goodguy gg;    gg.visit();    gg.visit2();}int main(){    test01();    system("pause");    return 0;}</code></pre><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对于已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>实现两个自定义数据类型相加的运算</p><p>对于内置的数据类型，编译器知道如何进行运算</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//加号运算符重载class Person{public:    //1、成员函数重载+号    // Person operator+(Person &p)    // {    //     Person temp;    //     temp.m_a = this->m_a + p.m_a;    //     temp.m_b = this->m_b + p.m_b;    //     return temp;    // }    int m_a;    int m_b;};//2、全局函数重载+号Person operator+(Person &p1, Person &p2){    Person temp;    temp.m_a = p1.m_a + p2.m_a;    temp.m_b = p1.m_b + p2.m_b;    return temp;}//函数重载的版本Person operator+(Person &p1, int num){    Person temp;    temp.m_a = p1.m_a + num;    temp.m_b = p1.m_b + num;    return temp;}void test01(){    Person p1;    p1.m_a = 10;    p1.m_b = 10;    Person p2;    p2.m_a = 10;    p2.m_b = 10;    //成员函数重载本质调用    //Person p3 = p1.operator+(p2);    //全局函数重载本质    //Person p3 = operator+(p1,p2);    Person p3 = p1 + p2;    //运算符重载，也可以发生函数重载    Person p4 = p1 + 100;    cout << "p3.m_a =" << p3.m_a << endl;    cout << "p3.m_b =" << p3.m_b << endl;    cout << "p4.m_a =" << p4.m_a << endl;    cout << "p4.m_b =" << p4.m_b << endl;}int main(){    test01();    system("pause");    return 0;}</code></pre><ul><li>对于内置的数据类型的表达式的运算符是不肯改变的</li><li>不要滥用运算符重载</li></ul><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>可以输出自定义数据类型</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//左移运算符重载class Person{    //如果成员属性是私有的，可以通过友元的方式去访问它    friend ostream &operator<<(ostream &cout, Person &p);public:    Person(int a, int b) //构造函数初始化    {        m_a = a;        m_b = b;    }private:    //利用成员函数重载左移运算符    //通常不会利用成员函数<<重载运算符    void operator<<(Person &p)    {    }    int m_a;    int m_b;};//只能利用全局函数重载左移运算符//cout属于ostream输出流类型ostream &operator<<(ostream &cout, Person &p) //本质   operator<<(cout,p)  简化  cout<<p{    cout << "m_a= " << p.m_a << "m_b=" << p.m_b << endl;    return cout;}void test01(){    Person p(10, 10); //有参构造的调用    // p.m_a = 10;    // p.m_b = 10;    // cout << p.m_a << endl;    // cout << p.m_b << endl;    cout << p << endl;    int main()    {        test01();        system("pause");        return 0;    }</code></pre><ul><li>重载左移运算符配合友元可以实现输出自定义数据类型</li></ul><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>通过重载递增运算符，实现自己的整型数据</p><ul><li>为什么成员函数重载使用时不需要传参</li></ul><p>==因为采用成员函数进行重载时，对象会调用这个函数，也就是说这个operator函数是对象本身的内容，因此并不需要额外再传递一个参数==</p><p> ==但是使用全局函数时则需要传递参数==</p><p>类的非静态成员变量返回对象本身，用return * this</p><ul><li>前置递增返回的时引用，后置递增返回的是值</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//重载递增运算符//自定义整形class myinteger{    friend ostream &operator<<(ostream &cout, myinteger myint);public:    myinteger() //构造函数初始化    {        m_num = 0;    }    //重载前置++运算符    //这个函数是类的成员函数，因此不用传参，直接可以对类内数据进行操作    //这里为什么不需要传参    //因为采用成员函数进行重载是，对象会调用这个函数，也就是说这个operator函数是对象本身的内容，因此并不需要额外再传递一个参数    //但是使用全局函数时则需要传递参数    // this指针指向这个对象，不需要传参用它本身就好    myinteger &operator++()    {        m_num++;        //再将自身做返回        return *this;    }    //重载后置++运算符    //返回值类型不可以作为重载的条件    //后置递增这里用了一个temp来记录递增之前的值，而不是直接返回原来的数的引用，但这里确实不可以再进行链式操作了    //因为返回来的对象不是原来的对象，再对temp进行temp++的操作递增的时temp 并不是myint,完全不需要链式运算了    myinteger operator++(int) //int 代表一个占位参数，可以区分前置和后置递增，只认int    {        //先  记录一下当下结果        myinteger temp = *this;        //后  递增        m_num++;        //最后将记录的结果做返回        //返回的对象是一个值，因为局部变量函数调用完就释放了   引用的话就执行非法操作了        return temp;    }private:    int m_num;};//重载<<(左运算符)运算符ostream &operator<<(ostream &cout, myinteger myint){    cout << myint.m_num;    return cout;}void test01(){    myinteger myint;    cout << ++(++myint) << endl;    cout << myint << endl;}void test02(){    myinteger myint;    cout << myint++ << endl;    cout << myint << endl;}int main(){    //test01();    test02();    system("pause");    return 0;}</code></pre><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ul><li><p>默认构造函数（无参，函数体为空）</p></li><li><p>默认析构函数（无参，函数体为空）</p></li><li><p>默认拷贝构造函数，对属性进行值拷贝</p></li><li><p>赋值运算符operator=，对属性进行值拷贝</p></li></ul><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><img src="/2021/06/25/c-xue-xi-2-0-he-xin-bian-cheng/Users\X_Bruce\AppData\Roaming\Typora\typora-user-images\image-20210521135537645.png" alt="image-20210521135537645"></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//赋值运算符重载class Person{public:    Person(int age)    {        m_age = new int(age);    }    //在析构函数中释放堆区的数据    //堆区的内存重复释放了    ~Person()    {        if (m_age != NULL)        {            delete m_age;            m_age = NULL;        }    }    //重载赋值运算符    Person &operator=(Person &p) //返回自身的引用    {        //编译器提供浅拷贝        //应该先判断是否有属性在堆区，如果有先释放干净，然后再深拷贝        //这时必须要释放内存，因为此时是赋值，不是之前的拷贝构造了，所有只有清空了指针的内容，才可以赋值新的内容进去        if (m_age != NULL)        {            delete m_age;            m_age = NULL;        }        //深拷贝        m_age = new int(*p.m_age);        //返回对象本身        return *this;    }    int *m_age;};void test01(){    Person p1(19);    Person p2(20);    Person p3(20);    p3 = p2 = p1; //赋值操作    cout << "p1的年龄为:" << *p1.m_age << endl;    cout << "p2的年龄为:" << *p2.m_age << endl;    cout << "p3的年龄为:" << *p3.m_age << endl;}int main(){    test01();    system("pause");    return 0;}</code></pre><h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//重载关系运算符class Person{public:    Person(string name, int age) //构造函数进行初始化    {        m_name = name;        m_age = age;    }    //重载关系运算符"=="号    bool operator==(Person &p)    {        if (this->m_age == p.m_age && this->m_name == p.m_name)        {            return true;        }        else        {            return false;        }    }    bool operator!=(Person &p)    {        if (this->m_age == p.m_age && this->m_name == p.m_name)        {            return false;        }        else        {            return true;        }    }    string m_name;    int m_age;};void test01(){    Person p1("tom", 18);    Person p2("jerry", 18);    if (p1 == p2) //重载这个等号    {        cout << "p1和p2是相等的" << endl;    }    else    {        cout << "p1和p2是不相等的" << endl;    }    if (p1 != p2) //重载这个等号    {        cout << "p1和p2是不相等的" << endl;    }    else    {        cout << "p1和p2是相等的" << endl;    }}int main(){    test01();    system("pause");    return 0;}</code></pre><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符（）也可以重载</li><li>由于重载后使用的方式非常像函数的调用，一次称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//函数调用运算符重载class myprint{public:    //重载函数调用运算符    void operator()(string test)    {        cout << test << endl;    }};void myprint02(string test){    cout << test << endl;}void test01(){    myprint mp;    mp("hello world");        //使用了重载之后的小括号，由于使用起来非常类似函数调用，因此称为仿函数    myprint02("hello world"); //函数调用}//仿函数非常灵活，没有固定写法//加法类class myadd{public:    int operator()(int num1, int num2)    {        return num1 + num2;    }};void test02(){    myadd mdd;    int ret = mdd(100, 100);    cout << "ret = " << ret << endl;    //匿名函数对象    //如果不想创建对象，就可以使用匿名函数对象    cout << myadd()(100, 100) << endl;}int main(){    //test01();    test02();    system("pause");    return 0;}</code></pre><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6 继承"></a>4.6 继承</h3><p>继承是面向对象的三大特性之一</p><p>我们在定义类的时候发现，下级别成员除了拥有上一级的共性，还有自己的特性，这个时候我们可以考虑利用继承的技术，减少代码的重复性</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p><em>//继承实现页面</em></p><p><em>//继承的好处，减少重复代码</em></p><p><em>//语法： class 子类：继承方式 父类</em></p><p><em>//子类  也称为  派生类</em></p><p><em>//父类  也称为  基类</em></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//普通实现页面//java页面// class Java// {// public://     void header()//     {//         cout << "首页、公开课、登录、注册...（公共头部）" << endl;//     }//     void footer()//     {//         cout << "帮助中心、交流合作、站内地图...（公共底部）" << endl;//     }//     void left()//     {//         cout << "Java、python、c++、...（公共分类列表）" << endl;//     }//     void content()//     {//         cout << "Java学科视频" << endl;//     }// };// //Python页面// class Python// {// public://     void header()//     {//         cout << "首页、公开课、登录、注册...（公共头部）" << endl;//     }//     void footer()//     {//         cout << "帮助中心、交流合作、站内地图...（公共底部）" << endl;//     }//     void left()//     {//         cout << "Java、python、c++、...（公共分类列表）" << endl;//     }//     void content()//     {//         cout << "Python学科视频" << endl;//     }// };// //C++页面// class Cp// {// public://     void header()//     {//         cout << "首页、公开课、登录、注册...（公共头部）" << endl;//     }//     void footer()//     {//         cout << "帮助中心、交流合作、站内地图...（公共底部）" << endl;//     }//     void left()//     {//         cout << "Java、python、c++、...（公共分类列表）" << endl;//     }//     void content()//     {//         cout << "C++学科视频" << endl;//     }// };//继承实现页面//继承的好处，减少重复代码//语法：  class  子类：继承方式  父类//子类   也称为   派生类//父类   也称为    基类class basepage{public:    void header()    {        cout << "首页、公开课、登录、注册...（公共头部）" << endl;    }    void footer()    {        cout << "帮助中心、交流合作、站内地图...（公共底部）" << endl;    }    void left()    {        cout << "Java、python、c++、...（公共分类列表）" << endl;    }};//Java页面class Java : public basepage{public:    void content()    {        cout << "Java学科视频" << endl;    }};//Python页面class Python : public basepage{public:    void content()    {        cout << "Python学科视频" << endl;    }};//C++页面class Cpp : public basepage{public:    void content()    {        cout << "C++学科视频" << endl;    }};void test01(){    cout << "Java下载视频的页面如下：" << endl;    Java ja;    ja.header();    ja.footer();    ja.left();    ja.content();    cout << "---------------------------" << endl;    cout << "Python下载视频的页面如下：" << endl;    Python py;    py.header();    py.footer();    py.left();    py.content();    cout << "---------------------------" << endl;    cout << "C++下载视频的页面如下：" << endl;    Cpp cp;    cp.header();    cp.footer();    cp.left();    cp.content();}int main(){    test01();    system("pause");    return 0;}</code></pre><p>继承的好处：==可以减少重复代码==</p><p>class A: public B;</p><p>A类称为子类或者派生类</p><p>B类称为父类或者基类</p><p><strong>派生类中的成员，包含两大部分：</strong></p><p>一类是从基类继承过来的，一类是自己增加的成员</p><p>从基类继承过来的变现其共性，而新增的成员体现个性</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类：继承方式   父类</code></p><p>继承方式一共有三种：</p><ul><li><p>公有继承</p></li><li><p>私有继承</p></li><li><p>保护继承</p></li></ul><p><img src="/2021/06/25/c-xue-xi-2-0-he-xin-bian-cheng/Users\X_Bruce\AppData\Roaming\Typora\typora-user-images\image-20210521184134502.png" alt="image-20210521184134502"></p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//继承方式//公共继承class base1{public:    int m_a;protected:    int m_b;private:    int m_c;};class son : public base1{public:    void fun()    {        m_a = 10; //父类中公共权限成员到子类中依然是公共权限        m_b = 10; //父类中保护权限成员到子类中依然是保护权限                  // m_c = 10;//父类中私有权限成员到子类中访问不到    }};void test01(){    son s1;    s1.m_a = 100;    //s1.m_b = 100;//到son中   m_b是保护权限类型   访问不到}// 保护继承class base2{public:    int m_a;protected:    int m_b;private:    int m_c;};class son2 : protected base2{public:    void fun()    {        m_a = 10; //父类中公共权限成员到子类中是保护权限        m_b = 10; //父类中保护权限成员到子类中依然是保护权限                  // m_c = 10;//父类中私有权限成员到子类中访问不到    }};void test02(){    son2 s2;    // s2.m_a = 100;//在son2中保护权限，类外访问不到    //s1.m_b = 100;//到son2中   m_b是保护权限类型   访问不到}// 私有继承class base3{public:    int m_a;protected:    int m_b;private:    int m_c;};class son3 : private base3{public:    void fun()    {       // m_a = 10; //父类中公共权限成员到子类中是私有权限        //m_b = 10; //父类中保护权限成员到子类中是私有权限                  // m_c = 10;//父类中私有权限成员到子类中访问不到    }};class grangson3 : public son3{public:    void fun()    {       // m_a = 100; //不管用什么方法都访问不到了    }};void test03(){    son3 s3;    // s3.m_a = 100;//在son3中私有权限，类外访问不到    //s3.m_b = 100;//到son3中   m_b是私有权限类型   访问不到}int main(){    system("pause");    return 0;}</code></pre><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p>从父类继承过来的成员，哪些属于子类对象中？</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//继承中的对象模型class base{public:    int m_a;protected:    int m_b;private:    int m_c;//只是被编译器隐藏了，但是还是会被继承下去};class son : public base{public:    int m_d;};//利用开发人员命令提示工具查看对象模型//跳转盘符//跳转文件路径  cd 具体路径下//查看命名// c1/d1  reportSingleClassLayout类名  文件名void test01(){    //在父类中所有的非静态的成员属性都会被子类继承下去    //父类中私有的成员属性是被编译器给隐藏了，因此是访问不到，但是确实被继承下来了    cout << "size of son =" << sizeof(son) << endl; //结果为16    cout << "size of base=" << sizeof(base) << endl;}int main(){    test01();    system("pause");    return 0;}</code></pre><h4 id="4-6-4-继承中的构造和析构顺序"><a href="#4-6-4-继承中的构造和析构顺序" class="headerlink" title="4.6.4 继承中的构造和析构顺序"></a>4.6.4 继承中的构造和析构顺序</h4><p>子类继承父类后，当创建子类对象时，也会调用父类的构造函数</p><p>那么父类和子类的构造和析构顺序是谁先谁后呢</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//继承中的构造和析构顺序class base{public:    base()    {        cout << "base构造函数！" << endl;    }    ~base()    {        cout << "base析构函数！" << endl;    }};class son : public base{public:    son()    {        cout << "son构造函数！" << endl;    }    ~son()    {        cout << "son析构函数！" << endl;    }};void test01() //栈区先进后出{    //base b;    //继承中的构造和析构顺序如下：    //先构造父类，再构造子类，析构的顺序和构造的顺序相反    son s1;}int main(){    test01();    system("pause");    return 0;}</code></pre><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据</p><ul><li>子类访问子类同名数据   直接访问即可</li><li>子类访问父类同名成员   需要加作用域</li><li>当子类与父类拥有同名的成员函数时，子类会隐藏父类中的同名成员函数，加作用域就可以访问到父类中的同名函数</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//继承中同名成员的处理方式class base{public:    base()    {        m_a = 100;    }    void fun()    {        cout << "base - fun()函数调用" << endl;    }    //发生了函数重载    void fun(int a)    {        cout << "base - fun(int a)函数调用" << endl;    }    int m_a;};class son : public base{public:    son()    {        m_a = 200;    }    void fun()    {        cout << "son - fun()函数调用" << endl;    }    int m_a;};//同名成员属性的处理方式void test01(){    son s;    // base b;    cout << "son下的m_a=" << s.m_a << endl;    //    cout << "base下的m_a=" << b.m_a << endl;    //如果通过子类对象访问到父类中的同名成员，需要加作用域    cout << "base下的m_a=" << s.base::m_a << endl;}//同名成员函数的处理void test02(){    son s;    s.fun(); //直接调用，调用的是子类中的同名成员函数    //如何调用父类中的同名成员呢？    s.base::fun(); //加上作用域即可调用父类的    //如果子类中出现了和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有的同名成员    //s.fun(100);    //如果想访问到父类中被隐藏的同名成员函数，需要加作用域    s.base::fun(100);}int main(){    //test01();    test02();    system("pause");    return 0;}</code></pre><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>继承中同名的静态成员再子类对象上如何进行访问</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p>静态成员变量的特点：</p><ul><li><p>所有对象都共享同一份数据</p></li><li><p>编译阶段就分配内存</p></li><li><p>类内声明，类外初始化</p></li></ul><p>静态成员函数的特点：</p><ul><li>只能访问静态成员变量，不能访问非静态成员变量</li><li>所有成员都共享同一份函数实例</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//继承中的同名静态成员处理方式class base{public:    static int m_a; //类内声明    static void fun()    {        cout << "base-static void fun()函数的调用" << endl;    }};int base::m_a = 100; //类外初始化class son : public base{public:    static int m_a;    static void fun()    {        cout << "son-static void fun()函数的调用" << endl;    }};int son::m_a = 200;//同名静态成员属性void test01(){    //1、通过对象来访问数据    cout << "通过对象来访问" << endl;    son s;    cout << "son下的m_a=" << s.m_a << endl;    cout << "base下的m_a=" << s.base::m_a << endl; //加个作用域    //2、通过类名来访问数据    cout << "通过类名来访问" << endl;    cout << "son下的 m_a = " << son::m_a << endl;   //类名的方法    cout << "base下的 m_a = " << base::m_a << endl; //类名的方法    //son通过类名的方式访问父类作用域下的m_a    //第一个::代表通过类名方式访问   第二个::代表访问父类作用域下    cout << "base下的 m_a = " << son::base::m_a << endl; //类名的方法}//同名静态成员函数void test02(){    //1、通过对象的方式访问    cout << "通过对象来访问" << endl;    son s;    s.fun();    s.base::fun();    //2、通过类名的方式访问    cout << "通过类名来访问" << endl;    base::fun();    //子类出现和父类同名静态成员函数，也会隐藏父类中的所有同名成员函数    //如果想访问父类中被隐藏的同名成员，需要加作用域    son::base::fun();}int main(){    //test01();    test02();    system("pause");    return 0;}</code></pre><p><strong>总结</strong>：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问方式（通过对象和通过类名）</p><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许一个类继承多个类</p><p>语法：<code>class  子类：继承方式   父类1，继承方式    父类2....</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p>C++实际开发中不建议使用多继承</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class base1{public:    base1()    {        m_a = 100;    }    int m_a;};class base2{public:    base2()    {        m_a = 200;    }    int m_a;};//子类  需要继承base1和base2//语法： class 子类  ：继承方式  父类1，继承方式  父类2...class son : public base1, public base2{public:    son()    {        m_c = 300;        m_d = 400;    }    int m_c;    int m_d;};void test01(){    son s;    cout << "sizeof son = " << sizeof(s) << endl;    //当父类中出现同名成员，需要加作用域区分    cout << "base1::m_a= " << s.base1::m_a << endl;    cout << "base2::m_a= " << s.base2::m_a << endl;}int main(){    test01();    system("pause");    return 0;}</code></pre><p>==多继承中如果父类中出现了同名情况，子类使用的时候需要加作用域==</p><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p>菱形继承的概念：</p><ul><li>两个派生类继承同一个基类</li><li>又有某个类同事继承着两个派生类</li><li>这种继承方式称为菱形继承，或者钻石继承</li></ul><p>底层<code>vbptr</code>指针：指向<code>vbtable</code>(一个虚基类表)</p><ul><li><code>v-virtual</code>(虚类)</li><li><code>b-base</code>(基类)</li><li><code>ptr-pointer</code>(指针)</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//动物类class animal{public:    int m_age;};//利用虚继承  可以解决菱形继承问题//在继承之前加关键字virtual 变为虚继承//animal类称为虚基类//羊类class sheep : virtual public animal{};//骆驼类class tuo : virtual public animal{};//羊驼类class sheeptuo : public sheep, public tuo{};void test01(){    sheeptuo s;    s.sheep::m_age = 18;    s.tuo::m_age = 19;    //当出现菱型继承的时候，两个父类拥有相同的数据，需要加作用域区分    cout << " s.sheep::m_age =" << s.sheep::m_age << endl;    cout << " s.tuo::m_age" << s.tuo::m_age << endl;    //不会出现不明确的情况了    cout << s.m_age << endl;    //这份数据我们知道只要有一份就可以了，菱型继承导致数据有两份，资源浪费}int main(){    test01();    system("pause");    return 0;}</code></pre><ul><li>菱形继承带来的主要问题时子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li><p>静态多态：函数重载和运算符重载属于静态多态，复用函数名</p></li><li><p>动态多态：派生类和虚函数实现运行时多态</p></li></ul><p>静态多态和动态多态区别：</p><ul><li><p>静态多态的函数地址早绑定 - 编译阶段确定函数地址</p></li><li><p>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</p></li></ul><p>动态多态满足条件</p><ul><li>得有继承关系</li><li>子类要重写(返回值类型相同，函数名相同，形参列表相同)父类的虚函数==virtual==关键字可写可不写</li><li>父类中要加==virtual==关键字</li></ul><p>动态多态的使用</p><ul><li>父类的指针或者引用指向子类的对象</li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;//多态//动物类class animal{public:    //虚函数    virtual void speak() //之后就会执行地址晚绑定了    {        cout << "动物在说话" << endl;    }};//猫类class cat : public animal{public:    void speak()    {        cout << "小猫在说话" << endl;    }};//狗类class dog : public animal{public:    void speak()    {        cout << "小狗在说话" << endl;    }};//执行说话的函数//地址早绑定  在编译阶段就确定了函数的地址//形参时animal引用   实参时cat//如果想让执行猫说话，那么这个函数地址皆不能提前绑定，需要在运行阶段进行绑定，地址晚绑定//加入虚函数之后，传入哪个对象就是哪种形态了void dospeak(animal &animal) //animal & animal = cat父类的引用指向接收子类的对象{    animal.speak(); //运行父子之间的类型转换}void test01(){    cat cat;    dospeak(cat);}void test02(){    dog dog;    dospeak(dog);}int main(){    // test01();    test02();    system("pause");    return 0;}</code></pre><h4 id="4-7-2-多态的原理剖析"><a href="#4-7-2-多态的原理剖析" class="headerlink" title="4.7.2 多态的原理剖析"></a>4.7.2 多态的原理剖析</h4><p>当子类重写了父类的虚函数</p><p>子类中的虚函数表  内部 会替换成  子类的虚函数地址</p><p>当父类的指针或引用指向子类对象是，就发生了多态</p><pre class=" language-c++"><code class="language-c++">animal & animal = cat    animal.speak会从cat的虚函数表中调用</code></pre><p>本质：父类中由于加入了<code>virtual</code>关键字，类的内部发生了结构的改变，多了一个虚函数表指针<code>vfptr</code>指向了一个虚函数表<code>vftable</code>,虚函数的内部记录着虚函数的入口地址，当子类重写了虚函数的时候，它会把自身的虚函表中的函数给替换掉，替换成子类的函数，所以当用父类的指针或者引用指向子类对象时由于本身还是一个子类的对象，当调用公共的<code>cpu</code>接口时它会从子类的虚函数表中找到子类的确实的入口地址，记下来就会指向子函数里的重新给函数的内容，就发生了多态</p><p><img src="/2021/06/25/c-xue-xi-2-0-he-xin-bian-cheng/Users\X_Bruce\AppData\Roaming\Typora\typora-user-images\image-20210524110102196.png" alt="image-20210524110102196"></p><h4 id="4-7-3-多态案例–-计算器类"><a href="#4-7-3-多态案例–-计算器类" class="headerlink" title="4.7.3 多态案例– 计算器类"></a>4.7.3 多态案例– 计算器类</h4><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算机类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p>==普通写法==</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//分别利用普通写法和多态技术实现计算器//普通写法class calculator{public:    int getresult(string oper)    {        if (oper == "+")        {            return m_num1 + m_num2;        }        else if (oper == "-")        {            return m_num1 - m_num2;        }        else if (oper == "*")        {            return m_num1 * m_num2;        }        else if (oper == "/")        {            return m_num1 / m_num2;        }    }    int m_num1;    int m_num2;};void test01(){    //创建一个计算机对象    calculator c;    c.m_num1 = 1;    c.m_num2 = 1;    cout << "两数相加的结果为：" << c.m_num1 << "+" << c.m_num2 << "=" << c.getresult("+") << endl;}int main(){    test01();    system("pause");    return 0;}</code></pre><p>如果想扩展新的功能，需要修改源码</p><p>在真实的开发中，提倡一种开闭原则</p><p>开闭原则：对扩展进行开放，对修改进行关闭</p><p>==多态编写==</p><h2 id="五、职工管理系统"><a href="#五、职工管理系统" class="headerlink" title="五、职工管理系统"></a>五、职工管理系统</h2><h3 id="5-1、菜单功能"><a href="#5-1、菜单功能" class="headerlink" title="5.1、菜单功能"></a>5.1、菜单功能</h3><p>在workermanager.cpp里面编写menu菜单.h文件里声明，.cpp文件里实现</p><pre class=" language-c++"><code class="language-c++">#include"workermanager.h"workermanager::workermanager(){}void workermanager::show_menu(){    cout << "*********************************************" << endl;    cout << "*************欢迎使用职工管理系统************" << endl;    cout << "*************** 0.退出管理程序***************" << endl;    cout << "*************** 1.增加职工信息***************" << endl;    cout << "*************** 2.显示职工信息***************" << endl;    cout << "*************** 3.删除离职职工***************" << endl;    cout << "*************** 4.修改职工信息***************" << endl;    cout << "*************** 5.查找职工信息***************" << endl;    cout << "*************** 6.按照编号排序***************" << endl;    cout << "*************** 7.清空所以文档***************" << endl;    cout << "*********************************************" << endl;    cout << endl;}workermanager::~workermanager(){}</code></pre><p>在main函数里面调用menu</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include"workermanager.h"int main(){    //实例化管理对象    workermanager wm;    //调用展示菜单成员函数    wm.show_menu();    system("pause");    return 0;}</code></pre><h3 id="5-2-推迟功能"><a href="#5-2-推迟功能" class="headerlink" title="5.2 推迟功能"></a>5.2 推迟功能</h3><h4 id="5-2-1-提供功能接口"><a href="#5-2-1-提供功能接口" class="headerlink" title="5.2.1 提供功能接口"></a>5.2.1 提供功能接口</h4><p>在main函数中提供分支选择，提供每个功能接口</p><pre class=" language-c++"><code class="language-c++">int main(){    //实例化管理对象    workermanager wm;    //用来存储用户选项    int choice = 0;    while (1)    {        //调用展示菜单成员函数        wm.show_menu();        cout << "请输入你的选择：" << endl;        cin >> choice;        switch (choice)        {        case 0: //退出系统            wm.exitsystem();            break;        case 1:    //增加职工            break;        case 2:    //显示职工            break;        case 3:    //删除职工            break;        case 4:    //修改职工            break;        case 5:    //查找职工            break;        case 6:    //排序职工            break;        case 7:    //清空文档            break;        default:    //清屏            break;        }    }        system("pause");    return 0;}</code></pre><p>在workermanager.h中加入了退出声明</p><p><code>void exitsystem();</code></p><p>在workermanager.cpp中加入了退出声明</p><pre class=" language-c++"><code class="language-c++">void workermanager::exitsystem(){    cout << "欢迎下次使用" << endl;    system("pause");    exit(0);//退出程序}</code></pre><h3 id="5-3-创建职工类"><a href="#5-3-创建职工类" class="headerlink" title="5.3 创建职工类"></a>5.3 创建职工类</h3><h4 id="5-3-1-创建职工抽象类"><a href="#5-3-1-创建职工抽象类" class="headerlink" title="5.3.1 创建职工抽象类"></a>5.3.1 创建职工抽象类</h4><p>==多态：一个接口有多种形态，由于创建的对象不同，显示的内容也不一样==</p><p>==多文件编写：.h文件中写函数的声明，.cpp文件中写函数的实现（类内函数要加作用域）==</p><p>职工的分类为：普通员工、经理、老板</p><p>将三种职工抽象到一个类（worker）中，利用多态管理不同的职工种类</p><p>职工的属性为：职工编号、职工姓名、职工所在的部门编号</p><p>职工的行为：岗位职责信息描述，获取岗位名称</p><p>头文件文件夹下创建worker.h文件并添加：</p><pre class=" language-c++"><code class="language-c++">#pragma once#include<iostream>#include<string>using namespace std;//职工抽象类class worker{public:    //显示个人信息    virtual void  showinfo() = 0;//纯虚函数    //获取岗位名称    virtual string getdeptname() = 0;    int m_id;//职工编号    string m_name;//职工姓名    int m_deptid;//职工所在部门名称编号};</code></pre><h4 id="5-3-2-创建普通员工类"><a href="#5-3-2-创建普通员工类" class="headerlink" title="5.3.2 创建普通员工类"></a>5.3.2 创建普通员工类</h4><p>普通员工类继承职工抽象类，并重写父类中纯虚函数</p><p>在头文件和原文件的文件夹下分别创建employee.h和employee.cpp文件</p><p>employee.h</p><pre class=" language-c++"><code class="language-c++">//普通员工文件#pragma once#include<iostream>#include"worker.h"using namespace std;//只做声明class employee:public worker{public:    //构造函数    employee(int id,string name,int did);    //显示个人信息    virtual void  showinfo();//纯虚函数    //获取岗位名称    virtual string getdeptname();};</code></pre><p>employee.cpp</p><pre class=" language-c++"><code class="language-c++">#include"employee.h"#include<string>//构造函数employee::employee(int id, string name, int did){    this->m_id = id;    this->m_name = name;    this->m_deptid = did;}//显示个人信息void  employee::showinfo()//纯虚函数{    cout << "职工的编号为：" << this->m_id        << "\t职工的姓名为：" << this->m_name        << "\t岗位：" << this->getdeptname()        << "\t岗位职责：完成经理交给的任务" << endl;}//获取岗位名称string employee::getdeptname(){    return string("员工");}</code></pre><h4 id="5-3-3-创建经理类"><a href="#5-3-3-创建经理类" class="headerlink" title="5.3.3 创建经理类"></a>5.3.3 创建经理类</h4><p>经理类继承职工抽象类，并重写父类中纯虚函数，和普通员工类似</p><p>在头文件和源文件下分别创建manager.h和manager.cpp文件</p><p>manager.h</p><pre class=" language-c++"><code class="language-c++">#pragma once#include<iostream>using namespace std;#include"worker.h"class manager:public worker{public:    //构造函数    manager(int id,string name,int did);    //显示个人信息    virtual void  showinfo();//纯虚函数    //获取岗位名称    virtual string getdeptname();    };</code></pre><p>manager.cpp</p><pre class=" language-c++"><code class="language-c++">#include"employee.h"#include<string>//构造函数employee::employee(int id, string name, int did){    this->m_id = id;    this->m_name = name;    this->m_deptid = did;}//显示个人信息void  employee::showinfo()//纯虚函数{    cout << "职工的编号为：" << this->m_id        << "\t职工的姓名为：" << this->m_name        << "\t岗位：" << this->getdeptname()        << "\t岗位职责：完成经理交给的任务" << endl;}//获取岗位名称string employee::getdeptname(){    return string("员工");}</code></pre><h4 id="5-3-4-创建老板类"><a href="#5-3-4-创建老板类" class="headerlink" title="5.3.4 创建老板类"></a>5.3.4 创建老板类</h4><p>老板类继承职工抽象类，并重写父类中的纯虚函数，和普通员工类似</p><p>在头文件和源文件的文件夹下分别创建boss.h和boss.cpp文件</p><p>boss.h</p><pre class=" language-c++"><code class="language-c++">#pragma once#include<iostream>using namespace std;#include"worker.h"class boss :public worker{    //重写父类中的纯虚函数public:    //构造函数    boss(int id, string name, int did);    //显示个人信息    virtual void  showinfo();//纯虚函数                             //获取岗位名称    virtual string getdeptname();};</code></pre><p>boss.cpp</p><pre class=" language-c++"><code class="language-c++">#include"boss.h"#include<string>//构造函数boss::boss(int id, string name, int did){    this->m_id = id;    this->m_name = name;    this->m_deptid = did;}//显示个人信息void  boss::showinfo()//纯虚函数{    cout << "职工的编号为：" << this->m_id        << "\t职工的姓名为：" << this->m_name        << "\t岗位：" << this->getdeptname()        << "\t岗位职责：管理公司所有事务" << endl;}                         //获取岗位名称string boss::getdeptname(){    return string("老板");}</code></pre><h3 id="5-4-测试多态"><a href="#5-4-测试多态" class="headerlink" title="5.4 测试多态"></a>5.4 测试多态</h3><p>在职工管理系统.cpp中添加测试函数，并且运行能够产生多态</p><pre class=" language-c++"><code class="language-c++">//测试代码    worker * worker = NULL;//指针必须要初始化，防止野指针    worker = new employee(1,"张三",1);    worker->showinfo();//运用到了多态    delete worker;    worker = new manager(2, "李四",2);    worker->showinfo();    delete worker;    worker = new boss(3, "王五", 3);    worker->showinfo();    delete worker;</code></pre><h3 id="5-5-添加职工"><a href="#5-5-添加职工" class="headerlink" title="5.5 添加职工"></a>5.5 添加职工</h3><p>批量添加职工，并且保存到文件中</p><h4 id="5-5-1-功能分析"><a href="#5-5-1-功能分析" class="headerlink" title="5.5.1 功能分析"></a>5.5.1 功能分析</h4><p>使用者在批量创建时，可能会创建不同种类的职工</p><p>如果想将所有不同种类的员工都放入同一个数组中，可以将所有员工的指针维护到一个数组里</p><p>如果想在程序中维护这个不定长度的数组，可以将数组创建到堆取，并利用worker**的指针维护</p><p>利用多态：父类的指针可以指向子类的对象，可以管控不同类型的指针</p><p><img src="/2021/06/25/c-xue-xi-2-0-he-xin-bian-cheng/vs2015\1.JPG" alt="1"></p><p>一个一级指针可以指向一个普通的一维数组，那么一个二级指针就可以指向一个一维指针数组</p><p>work * [5]是一个数组指针，它指向数组中每个元素地址，但要对这个数组地址进行修改就要再加一个指针指向它就是worker **</p><p>父类指针很指向子类对象，然后把父类指针用数组记录下来，就是二级指针的作用</p><h4 id="5-5-2-功能实现"><a href="#5-5-2-功能实现" class="headerlink" title="5.5.2 功能实现"></a>5.5.2 功能实现</h4><p>在workermanager.h头文件中添加成员属性代码：</p><pre class=" language-c++"><code class="language-c++">#include"worker.h"#include"employee.h"#include"manager.h"#include"boss.h"</code></pre><p>在workermanager构造函数中初始化属性</p><pre class=" language-c++"><code class="language-c++">workermanager::workermanager(){    //初始化属性    this->m_empnum = 0;//一开始额职工数为0    this->m_emparry = NULL;//指针指向为空}</code></pre><p>在workermanager.h中添加成员函数</p><pre class=" language-c++"><code class="language-c++">    //记录职工人数    int m_empnum;    //职工数组指针    worker **m_emparry;    //添加职工    void add_emp();</code></pre><p>workermanager.cpp中实现该函数</p><pre class=" language-c++"><code class="language-c++">void workermanager::add_emp(){    cout << "请输入添加职工的数量：" << endl;    int addnum = 0;//保存用户的输入数量    cin >> addnum;    if (addnum>0)    {        //添加        //计算一下添加新空间大小        //新空间人数 = 原来空间人数 + 新增人数        int newsize = this->m_empnum + addnum;        //开辟新空间        worker **newspace = new worker *[newsize];//newspace用来管理父类指针        //将原来空间下的数，拷贝到新空间下        if (this->m_emparry!=NULL)        {            for (int i = 0; i < this->m_empnum; i++)            {                newspace[i] = this->m_emparry[i];            }        }        //批量添加新数据        for (int i = 0; i < addnum; i++)        {            int id;//职工编号            string name;//职工姓名            int dselect;//部门选择            cout << "请输入第" << i + 1 << "个新职工的编号为：" << endl;            cin >> id;            cout << "请输入第" << i + 1 << "个新职工的姓名为：" << endl;            cin >> name;            cout << "请选择该职工的岗位" << endl;            cout << "1、普通职工" << endl;            cout << "2、经理" << endl;            cout << "3、老板" << endl;            cin >> dselect;            worker * worker = NULL;            //父类指针指向子类的对象            switch (dselect)            {            case 1:                worker = new employee(id, name, 1);                break;            case 2:                worker = new manager(id, name, 2);                break;            case 3:                worker = new boss(id, name, 3);                break;            default:                break;            }            //将创建职工指针，保存到数组中            newspace[this->m_empnum + i] = worker;        }        //释放原有的空间        //这里只是释放了指针数组，对指针数组每个元素指向的空间并没有被释放掉        delete[] this->m_emparry;        //更改新空间的指向        this->m_emparry = newspace;        //更新新的职工人数        this->m_empnum = newsize;        //成功添加后保存到文件中        //提示添加成功        cout << "成功添加" << addnum << "名新职工" << endl;    }    else    {        cout << "你输入错误" << endl;    }    //按任意键后清屏回到上级目录    system("pause");    system("cls");}</code></pre><h3 id="5-6-文件交互-写文件"><a href="#5-6-文件交互-写文件" class="headerlink" title="5.6 文件交互-写文件"></a>5.6 文件交互-写文件</h3><p>对文件进行读写：</p><p>添加功能中，我们只是将所有的数据加入到内存中，一旦程序结束之后就无法保存了，因此文件管理中需要一个与文件进行交互的功能，对于文件进行读写操作</p><h4 id="5-6-1-设定文件路径"><a href="#5-6-1-设定文件路径" class="headerlink" title="5.6.1 设定文件路径"></a>5.6.1 设定文件路径</h4><p>设定文件路径，在workermanager.h中添加宏常量，并且包含头文件fstream</p><pre class=" language-c++"><code class="language-c++">#include<fstream>#define FILENAME "emplist.txt"</code></pre><h4 id="5-6-2-成员函数声明"><a href="#5-6-2-成员函数声明" class="headerlink" title="5.6.2 成员函数声明"></a>5.6.2 成员函数声明</h4><p>在workermanager.h中类里添加成员函数<code>void save()</code></p><pre class=" language-c++"><code class="language-c++">    //保存文件    void save();</code></pre><h4 id="5-6-3-保存文件功能实现"><a href="#5-6-3-保存文件功能实现" class="headerlink" title="5.6.3 保存文件功能实现"></a>5.6.3 保存文件功能实现</h4><pre class=" language-c++"><code class="language-c++">//保存文件void workermanager::save(){    ofstream ofs;    ofs.open(FILENAME, ios::out);//用输出的方式打开文件 --写文件    //将每个人的数据写入到文件中    for (int i = 0; i < this->m_empnum; i++)    {        ofs << this->m_emparry[i]->m_id << " "            << this->m_emparry[i]->m_name << " "            << this->m_emparry[i]->m_deptid << endl;    }    //关闭文件    ofs.close();}</code></pre><h3 id="5-7-文件交互-读文件"><a href="#5-7-文件交互-读文件" class="headerlink" title="5.7 文件交互-读文件"></a>5.7 文件交互-读文件</h3><p>将文件中的内容读取到程序中</p><p>虽然实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有将文件中的数据读取到程序中，且程序功能中还有清空文件的需求，因此构造函数初始化数据的情况分为三种</p><ul><li><p>第一次使用，文件未创建</p></li><li><p>文件存在，但是数据被用户清空</p></li><li><p>文件存在，并且保存职工的所有数据</p></li></ul><h4 id="5-7-1-文件未创建"><a href="#5-7-1-文件未创建" class="headerlink" title="5.7.1 文件未创建"></a>5.7.1 文件未创建</h4><p>在workermanager.h中添加新的成员属性m_filemplty标志文件是否为空</p><pre class=" language-c++"><code class="language-c++">    //判断文件是否为空 标志    bool m_fileisempty;</code></pre><p>修改workermanager.cpp中构造函数代码：</p><pre class=" language-c++"><code class="language-c++">//1、文件不存在    ifstream ifs;    ifs.open(FILENAME, ios::in);//读文件    //判断文件是否存在    if(!ifs.is_open())    {        cout << "文件不存在" << endl;        //初始化属性        //初始化记录人数        this->m_empnum = 0;        //初始化数组指针        this->m_emparry = NULL;        //初始化文件是否为空        this->m_fileisempty = true;        ifs.close();        return;    }</code></pre><h4 id="5-7-2-文件存在且数据为空"><a href="#5-7-2-文件存在且数据为空" class="headerlink" title="5.7.2 文件存在且数据为空"></a>5.7.2 文件存在且数据为空</h4><p>在workermanager.cpp中的构造函数追加代码：</p><pre class=" language-c++"><code class="language-c++">//2、文件存在，数据为空    char ch;    ifs >> ch;//读走一个标识符    if (ifs.eof())//判断文件存在且没有数据    {        cout << "文件为空！" << endl;        this->m_empnum = 0;        this->m_fileisempty = true;        this->m_emparry = NULL;        ifs.close();        return;    }</code></pre><p>成功添加职工后，应该更改文件不为空的标志</p><p>在<code>void workermanager::add_emp()</code>成员函数中添加：</p><pre class=" language-c++"><code class="language-c++">        this->m_fileisempty = false;        //成功添加后保存到文件中</code></pre><h4 id="5-7-3-文件存在且保存职工数据"><a href="#5-7-3-文件存在且保存职工数据" class="headerlink" title="5.7.3 文件存在且保存职工数据"></a>5.7.3 文件存在且保存职工数据</h4><p>1、获取记录的职工人数</p><p>在workermanager.h中添加成员函数<code>int  get_empnum();</code></p><pre class=" language-c++"><code class="language-c++">    //统计文件中的人数    int get_empnum();</code></pre><p>workermanager.cpp中实现</p><pre class=" language-c++"><code class="language-c++">//统计文件中的人数int workermanager::get_empnum(){    ifstream ifs;    ifs.open(FILENAME, ios::in);//打开文件  读文件    int id;    string name;    int did;    int num = 0;    //流提取符>>会跳过输入流里的空格    //读文件，读到空格或者换行符就会停止，然后进行下一次读取    while (ifs>>id&&ifs>>name&&ifs>>did)//读数据，按行读    {        //统计人数变量        num++;    }    return num;}</code></pre><p>在workermanager.cpp构造函数中继续追加代码：</p><pre class=" language-c++"><code class="language-c++">    //3、文件存在，并且记录数据    int num = this->get_empnum();    cout << "职工人数为：" << num << endl;    this->m_empnum = num;</code></pre><p>2、初始化数组</p><p>根据职工的数据，初始化workermanager中的worker**m_emparray指针</p><p>在workermanager.h中添加成员函数<code>void init_emp()</code>:</p><pre class=" language-c++"><code class="language-c++">    //初始化职工    void init_emp();</code></pre><p>在workermanager.cpp中实现：</p><pre class=" language-c++"><code class="language-c++">void workermanager::init_emp()//将文件中的数据读入内存{    ifstream ifs;    ifs.open(FILENAME, ios::in);    int id;    string name;    int did;    int index = 0;    while (ifs>>id&&ifs>>name&&ifs>>did)    {        worker * worker = NULL;        if (did == 1)//普通员工        {            worker = new employee(id, name, did);        }        else if (did == 2)//经理        {            worker = new manager(id, name, did);        }        else //老板        {            worker = new boss(id, name, did);        }        this->m_emparry[index] = worker;        index++;    }    //关闭文件    ifs.close();}</code></pre><p>在workermanager.cpp的构造函数中追加代码</p><pre class=" language-c++"><code class="language-c++">//3、文件存在，并且记录数据    int num = this->get_empnum();//    cout << "职工人数为：" << num << endl;    this->m_empnum = num;    //先统计文件中有几个员工，再给数组开辟多大的内存，然后开始从文件中把数据读到数组中    //初始化职工，并且显示出来    //开辟空间     this->m_emparry = new worker*[this->m_empnum];    //将文件中的数据，存到数组中    this->init_emp();    //测试代码    for (int i = 0; i < this->m_empnum; i++)    {        cout << "职工编号：" << this->m_emparry[i]->m_id            << "姓名：" << this->m_emparry[i]->m_name            << "部门编号：" << this->m_emparry[i]->m_deptid << endl;     }</code></pre><h3 id="5-8-显示职工"><a href="#5-8-显示职工" class="headerlink" title="5.8 显示职工"></a>5.8 显示职工</h3><p>显示当前所有职工信息</p><h4 id="5-8-1-显示职工函数声明"><a href="#5-8-1-显示职工函数声明" class="headerlink" title="5.8.1 显示职工函数声明"></a>5.8.1 显示职工函数声明</h4><p>在workermanager.h中添加成员函数<code>void show_emp;</code></p><pre class=" language-c++"><code class="language-c++">    //显示职工    void show_emp();</code></pre><h4 id="5-8-2-显示职工函数实现"><a href="#5-8-2-显示职工函数实现" class="headerlink" title="5.8.2 显示职工函数实现"></a>5.8.2 显示职工函数实现</h4><p>在workermanager.cpp中实现成员函数<code>void show_emp;</code></p><pre class=" language-c++"><code class="language-c++">//显示职工void workermanager::show_emp(){    //判断文件是否为空    if (this->m_fileisempty)    {        cout << "文件不存在或记录为空" << endl;    }    else    {        for (int i = 0; i < this->m_empnum; i++)        {            //利用多态调用程序接口            this->m_emparry[i]->showinfo();        }    }    //按任意键清屏    system("pause");    system("cls");}</code></pre><h3 id="5-9-删除职工"><a href="#5-9-删除职工" class="headerlink" title="5.9 删除职工"></a>5.9 删除职工</h3><p>按照职工的变化进行删除职工操作</p><h4 id="5-9-1-删除职工函数声明"><a href="#5-9-1-删除职工函数声明" class="headerlink" title="5.9.1 删除职工函数声明"></a>5.9.1 删除职工函数声明</h4><p>在workermanager.h中添加成员函数<code>void del_emp();</code></p><pre class=" language-c++"><code class="language-c++">    //删除职工    void del_emp();</code></pre><h4 id="5-9-2-职工是否存在函数声明"><a href="#5-9-2-职工是否存在函数声明" class="headerlink" title="5.9.2 职工是否存在函数声明"></a>5.9.2 职工是否存在函数声明</h4><p>很多功能都需要用到根据职工是否存在来进行操作如：删除职工、修改职工、查找职工</p><p>因此添加该公告函数，以便后续调用</p><p>在workermanager.h中添加成员函数<code>int  isexist(int);</code></p><pre class=" language-c++"><code class="language-c++">//判断职工是否存在  如果存在返回职工所在数组中的位置，不存在返回-1    int isexist(int id);</code></pre><h4 id="5-9-3-职工是否存在函数实现"><a href="#5-9-3-职工是否存在函数实现" class="headerlink" title="5.9.3 职工是否存在函数实现"></a>5.9.3 职工是否存在函数实现</h4><p>在workermanger.cpp中实现成员函数<code>int isexist(inr id)</code></p><pre class=" language-c++"><code class="language-c++">//判断职工是否存在  如果存在返回职工所在数组中的位置，不存在返回-1int workermanager::isexist(int id){    int index = -1;    for (int i = 0; i < this->m_empnum; i++)    {        if (this->m_emparry[i]->m_id == id)        {            //找到职工            index = i;            break;        }    }    return index;}</code></pre><h4 id="5-9-4-删除职工函数实现"><a href="#5-9-4-删除职工函数实现" class="headerlink" title="5.9.4 删除职工函数实现"></a>5.9.4 删除职工函数实现</h4><p>delete是释放内存，不是删除数组</p><p>在workermanger.cpp中实现成员函数<code>void workermanager::del_emp()</code></p><pre class=" language-c++"><code class="language-c++">//删除职工void workermanager::del_emp(){    if (this->m_fileisempty)    {        cout << "文件不存在或记录为空" << endl;    }    else    {        //按照职工编号进行删除        cout << "请输入想要删除的职工编号：" << endl;        int id = 0;        cin >> id;        int index = this->isexist(id);        if (index!=-1)//说明职工存在，并且要删除掉index位置上的职工        {            for (int i = index; i < this->m_empnum-1; i++)            {                //数据前移                this->m_emparry[i] = this->m_emparry[i + 1];            }            this->m_empnum--;//更新下数组中记录人员个数            //数据同步更新到文件中            this->save();            cout << "删除成功" << endl;        }        else        {            cout << "删除失败，未找到该职工" << endl;        }    }    //按任意键清屏    system("pause");    system("cls");}</code></pre><h3 id="5-10-修改职工"><a href="#5-10-修改职工" class="headerlink" title="5.10 修改职工"></a>5.10 修改职工</h3><p>按照职工的编号对职工信息进行修改并保存</p><h4 id="5-10-1-修改职工函数声明"><a href="#5-10-1-修改职工函数声明" class="headerlink" title="5.10.1 修改职工函数声明"></a>5.10.1 修改职工函数声明</h4><p>在workermanager.h中添加成员函数<code>void mod_emp();</code></p><pre class=" language-c++"><code class="language-c++">    //修改职工    void mod_emp();</code></pre><h4 id="5-10-2-修改职工函数实现"><a href="#5-10-2-修改职工函数实现" class="headerlink" title="5.10.2 修改职工函数实现"></a>5.10.2 修改职工函数实现</h4><p>在workermanager.cpp中添加成员函数<code>void mod_emp();</code></p><pre class=" language-c++"><code class="language-c++">因为指针的指向没有变，所以该职工对应的岗位和岗位职责就不会变//修改职工void workermanager::mod_emp(){    if (this->m_fileisempty)    {        cout << "文件不存在或记录为空" << endl;    }    else    {        cout << "请输入修改职工的编号" << endl;        int id;        cin >> id;        int ret = this->isexist(id);        if(ret!=-1)        {            //查找到编号的职工            //清空堆区为了替换            //不能直接覆盖，类型可能就变了            delete this->m_emparry[ret];            int newid = 0;            string newname = "";            int dselect = 0;            cout << "查到：" << id << "号员工，请输入新职工号：" << endl;            cin >> newid;            cout << "请输入新姓名：" << endl;            cin >> newname;            cout << "请输入岗位：" << endl;            cout << "1、普通职工" << endl;            cout << "2、经理" << endl;            cout << "3、老板" << endl;            cin >> dselect;            worker * worker = NULL;            switch (dselect)            {            case 1:                worker = new employee(newid, newname, dselect);                break;            case 2:                worker = new manager(newid, newname, dselect);                break;            case 3:                worker = new boss(newid, newname, dselect);                break;            default:                break;            }            //更新数据到数组中            this->m_emparry[ret] = worker;            cout << "修改成功！" << endl;            //数据保存到文件中            this->save();        }        else        {            cout << "修改失败，查无成人" << endl;        }    }    //按任意键清屏    system("pause");    system("cls");}</code></pre><h3 id="5-11-查找职工"><a href="#5-11-查找职工" class="headerlink" title="5.11 查找职工"></a>5.11 查找职工</h3><p>提供两种查找职工的方式，一种按照职工编号，一种按照职工姓名</p><h4 id="5-11-1-查找职工函数声明"><a href="#5-11-1-查找职工函数声明" class="headerlink" title="5.11.1 查找职工函数声明"></a>5.11.1 查找职工函数声明</h4><p>在workermanager.h中添加成员函数<code>void find_emp()</code></p><pre class=" language-c++"><code class="language-c++">    // 查找职工    void find_emp();</code></pre><h4 id="5-11-2-查找职工函数实现"><a href="#5-11-2-查找职工函数实现" class="headerlink" title="5.11.2 查找职工函数实现"></a>5.11.2 查找职工函数实现</h4><p>在workermanager.cpp中实现成员函数<code>void find_emp()</code></p><pre class=" language-c++"><code class="language-c++">// 查找职工void workermanager::find_emp(){    if (this->m_fileisempty)    {        cout << "文件不存在或者记录为空：" << endl;    }    else    {        cout << "请输入你要选择的查找方式" << endl;        cout << "1、按照编号查找" << endl;        cout << "2、按照姓名查找" << endl;        int select = 0;        cin >> select;        //按照职工编号查找        if (select == 1)        {            int id;            cout << "请输入查找的职工编号" << endl;            cin >> id;            int ret = isexist(id);//返回在数组中的位置            if (ret != -1)            {                cout << "查找成功，该职工信息如下：" << endl;                this->m_emparry[ret]->showinfo();            }            else            {                cout << "查找失败，查无此人" << endl;            }        }        //按照姓名查找        else if (select == 2)        {            string name;            cout << "请输入要查找的姓名：" << endl;            cin >> name;            int ret = stexist(name);//返回在数组中的位置            if (ret != -1)            {                cout << "查找成功，该职工信息如下：" << endl;                this->m_emparry[ret]->showinfo();            }            else            {                cout << "查找失败，查无此人" << endl;            }        }    }    //清屏操作    system("pause");    system("cls");}</code></pre><h3 id="5-12-排序"><a href="#5-12-排序" class="headerlink" title="5.12 排序"></a>5.12 排序</h3><p>按照职工编号进行排序，排序的顺序由用户指定</p><h4 id="5-12-1-排序函数声明"><a href="#5-12-1-排序函数声明" class="headerlink" title="5.12.1 排序函数声明"></a>5.12.1 排序函数声明</h4><p>在workermanager.h中添加成员函数<code>void sort_emp</code></p><pre class=" language-c++"><code class="language-c++">    //按照编号排序    void sort_emp();</code></pre><h4 id="5-12-2-排序函数实现"><a href="#5-12-2-排序函数实现" class="headerlink" title="5.12.2 排序函数实现"></a>5.12.2 排序函数实现</h4><p>在workermanager.cpp中添加成员函数<code>void sort_emp</code></p><pre class=" language-c++"><code class="language-c++">//按照编号排序void workermanager::sort_emp(){    if (this->m_fileisempty)    {        cout << "文件不存在或记录为空" << endl;        system("pause");        system("cls");    }    else    {        cout << "请选择排序方式：" << endl;        cout << "1、按照工号进行升序" << endl;        cout << "2、按照工号进行降序" << endl;        int select = 0;        cin >> select;        for (int i = 0; i < m_empnum; i++)        {            int minormax = i;//声明最小值或最大值下标            for (int j = i; j < this->m_empnum; j++)            {                if ((select == 1 ))//升序                {                    if (this->m_emparry[minormax]->m_id > this->m_emparry[j]->m_id)                    {                        minormax = j;                    }                }                else //降序                {                    if (this->m_emparry[minormax]->m_id < this->m_emparry[j]->m_id)                    {                        minormax = j;                    }                }                            }                        //判断一开始认定的最小值或最大值是不是计算的最小值或最大值，如果不是，交换数据            if (i!=minormax)            {                worker * temp = this->m_emparry[i];                this->m_emparry[i] = this->m_emparry[minormax];                this->m_emparry[minormax] = temp;            }        }        cout << "排序成功！排序后的结果为：" << endl;        this->save();//排序后结果保存在文件中        this->show_emp();//展示所有职工    }}</code></pre><h3 id="5-13-清空文件"><a href="#5-13-清空文件" class="headerlink" title="5.13 清空文件"></a>5.13 清空文件</h3><p>将文件中记录数据清空</p><h4 id="5-13-1-清空函数声明"><a href="#5-13-1-清空函数声明" class="headerlink" title="5.13.1 清空函数声明"></a>5.13.1 清空函数声明</h4><p>在workermanager.h中添加成员函数</p><pre class=" language-c++"><code class="language-c++">    //清空文件    void clean_file();</code></pre><h4 id="5-13-2-清空函数实现"><a href="#5-13-2-清空函数实现" class="headerlink" title="5.13.2 清空函数实现"></a>5.13.2 清空函数实现</h4><pre class=" language-c++"><code class="language-c++">//清空文件void workermanager::clean_file(){    cout << "确定清空吗？" << endl;    cout << "1、确定" << endl;    cout << "2、返回" << endl;    int  select = 0;    cin >> select;    if (select == 1)    {        //清空文件        ofstream ofs(FILENAME,ios::trunc);//删除文件后重新创建        ofs.close();        if (this->m_emparry !=NULL)        {            //删除堆区的每个职工对象            for (int i = 0; i < this->m_empnum; i++)            {                delete this->m_emparry[i];                this->m_emparry[i] = NULL;            }            //删除堆区数组指针            delete[] this->m_emparry;            this->m_emparry = NULL;            this->m_empnum = 0;            this->m_fileisempty = true;        }        cout << "清空成功" << endl;    }    system("pause");    system("cls");}</code></pre><blockquote><p>至此，程序任务与功能已全部完成，核心编程部分告一段落！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于虚拟机的Ubuntu网络连接解决方案</title>
      <link href="2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/"/>
      <url>2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天准备使用虚拟机，突然发现连不上网了<span class="github-emoji"><span>🙉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f649.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，之前天真的以为是自动连接的<span class="github-emoji"><span>😕</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f615.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，Ubuntu界面上的wify标志也没了，今天还有资源包需要安装使用，不由的一阵头皮发麻，后来在网上找了好多方法，最终才把它弄好<span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，小问题耽搁了不少时间，鉴于此记录下解决方案，供粗心的路人少踩坑<span class="github-emoji"><span>🆘</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f198.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><p>首先，点击下面这个编辑选项</p><img src="/2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/1.png" class=""><p>选择虚拟网络编辑器，选择桥接模式，并且选择带有<code>Wireless-AC</code>的（如果是用Wifi的话）。</p><img src="/2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/2.png" class=""><p>然后打开自己电脑的网络连接</p><img src="/2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/3.png" class=""><p>找到带有VMware字样的（我改了第一个就成功了）</p><img src="/2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/4.png" class=""><p>右击属性，选择设置</p><img src="/2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/5.png" class=""><p>选择自动获取ip地址</p><img src="/2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/6.png" class=""><p>打开虚拟机，更改为net模式</p><img src="/2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/7.png" class=""><p>==如果wify图表消失的话，可以按下列操作==</p><pre class=" language-c++"><code class="language-c++">sudo service network-manager stopsudo rm /var/lib/NetworkManager/NetworkManager.statesudo service network-manager start</code></pre><p>再将网络适配器改成桥接模式或者NAT模式再输入</p><p><code>sudo service network-manager start</code></p><p>之后就连上网络啦！！！</p><img src="/2021/06/01/ubuntu-xu-ni-ji-de-wang-luo-lian-jie-jie-jue-fang-an/8.png" class="">]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用UltraISO制作Ubuntu_18.04U盘启动盘</title>
      <link href="2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/"/>
      <url>2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为菜鸟程序员的我在学习linux的道路上一直都在用虚拟机运行Ubuntu操作系统，然而对于想要极致发挥linux性能，体验linux无穷魅力的同学来说，PC端的linux操作系统当然是不二选择啦，于是乎，我们需要迈出第一步，制作一个自己的Ubuntu U盘启动盘，开始吧  go  go   go !</p></blockquote><ul><li><p>制作工具：UltraISO（百度直搜既可，下载最新版）</p></li><li><p>linux版本：Ubuntu_18.04 （现阶段个人认为较为稳定的版本）</p></li><li><p>U盘：不小于1G</p></li></ul><p>​     首先,从Ubuntu官网<code>http://cn.ubuntu.com/download/</code>下载系统的iso文件 用来制作的U盘需要是FAT32格式的，可以通过格式化U盘更改（注意，如果U盘已经写入过隐藏分区了，需要在磁盘管理里面删除相关隐藏分区然后合并为一个大分区后格式化为FAT32）</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/1.png" class><p>接下来从网上下载新版UltraISO软件安装</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/2.png" class><p>打开软件后点击下图中红色划线标识按钮（如果ISO文件是默认用UltraISO打开也可以直接双击iso文件打开），找到Ubuntu ISO文件所在文件夹，选中并点击打开</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/3.png" class><p>打开后的界面为：</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/4.png" class><p>点击 “启动→写入硬盘映像…”</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/5.png" class><p>写入方式选择USB-HDD+或者USB-HDD均可（一般用HDD+）【隐藏启动分区最好选择无，省的以后格式化麻烦】【刻录校验可要可不要】</p><p>点击 “便捷启动→写入新的驱动器引导扇区→Syslinux”【这一步的作用是让开机启动时能够以U盘启动 Linux安装系统，否则U盘就相当于是存了数据而不是启动盘】</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/6.png" class><p>点击确定，提示成功</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/7.png" class><p>点击写入，选择“是”</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/8.png" class><p>写入需要等待一段时间  完成后即可，最后我们可以查看</p><img src="/2021/06/01/yong-ultraiso-zhi-zuo-ubuntu-18-04u-pan-qi-dong-pan/9.png" class><p>至此，我们的Ubuntu U盘启动盘就已经制作完毕，插入主机，进入bois选择U盘启动正常安装即可</p><p>是不是很简单哈  ，大家赶紧来试试吧！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu_18.04 </tag>
            
            <tag> UltraISO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菜鸟程序员内功心法--C++（基础编程）</title>
      <link href="2021/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/"/>
      <url>2021/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C++是在C语言的基础上开发的一种面向对象编程语言，应用非常广泛。常用于系统开发，引擎开发等应用领域，支持类、封装、继承、多态等特性。此外，C++语言灵活，运算符的数据结构丰富、具有结构化控制语句、程序执行效率高，而且具有高级语言与汇编语言的优点。正因为这样，C++作为最复杂的语言之一，其内容也是纷繁复杂，对于学习者来说是不小的挑战！<span class="github-emoji"><span>💔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f494.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><blockquote><p>作为一名初级菜鸟程序员<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，虽然C++学习道路漫漫，但本着励志做一名可以光明正大摸鱼的程序员来说<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>博主最近也在如火如荼的进行着C++学习，现在将近半个月的学习笔记心得记录总结，希望可以对有缘人有所帮助。货不多说上干货！<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>（本篇较为基础适合小白入门，亲测有效！）</p></blockquote><p>编译器：vscode  (当然也可以用Visual Studio集成开发环境等)，配置请看我的另一篇文章</p><p>重要的事情说三遍：一定要亲手敲出来！一定要亲手敲出来！一定要亲手敲出来！加油！！！</p><h1 id="C-学习-1-0-初级编程"><a href="#C-学习-1-0-初级编程" class="headerlink" title="C++学习-1.0_初级编程"></a>C++学习-1.0_初级编程</h1><p>##一、C++初识</p><h3 id="1-1-hello-world"><a href="#1-1-hello-world" class="headerlink" title="1.1 hello world"></a><strong>1.1 hello world</strong></h3><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;int main(){    cout <<"hello world"<< endl;    system("pause");    return 0;}</code></pre><ul><li><p>单行注释//；多行注释/*   */</p><p><em>main函数是一个程序的入口</em>  ==一个源文件里main函数只能有一个==</p></li></ul><h3 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a><strong>2.1 变量</strong></h3><p>  存在的意义：方便管理内存空间</p><p>  变量创建： 数据类型    变量名称 = 变量初始值 ==int a=10==</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;int main(){   int a=10;    cout <<"a="<< a <<endl;    system("pause");    return 0;}</code></pre><h3 id="3-1-常量"><a href="#3-1-常量" class="headerlink" title="3.1 常量"></a><strong>3.1 常量</strong></h3><pre class=" language-c++"><code class="language-c++">用于记录不可修改的数据，一旦修改就会报错c++两种定义方式：`1.#define   常量名   常量值==通常在文件上方定义==   ``2.const    数据类型   常量名=常量值  `+ 通常在变量定义前面加关键字const,修饰该变量为常量。不可修改</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;//#define 宏常量#define DAY 7int main(){    cout << "一周总共有：" << DAY << "天" << endl;    const int month = 12;    cout << "一年有：" << month << "月" << endl;    system("pause");    return 0;}</code></pre><h3 id="4-1-c-标识符命名规则"><a href="#4-1-c-标识符命名规则" class="headerlink" title="4.1 c++标识符命名规则"></a><strong>4.1 c++标识符命名规则</strong></h3><ul><li><p>标识符不能是关键字</p></li><li><p>标识符<strong>只能</strong>由字母数字下划线组成</p></li><li><p>第一个字符<strong>必须</strong>为字母或下划线</p></li><li><p>标识符中字母区分大小写</p><p>==标识符要知名见意==</p></li></ul><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a><strong>二、数据类型</strong></h2><p>  存在意义：给变量分配一个合适的内存空间</p><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td><td>-2^15 - 2^15-1</td></tr><tr><td>int(整型)</td><td>4字节</td><td>-2^31 - 2^31-1</td></tr><tr><td>long (长整型)</td><td>W_4;LIN_4;8</td><td>-2^31 - 2^15-1</td></tr><tr><td>long  long(长长整型)</td><td>8字节</td><td>-2^63 - 2^63-1</td></tr></tbody></table><ul><li>sizeof:统计数据类型所占内存大小<code>sizeof(数据类型 或 变量)</code></li></ul><h3 id="2-2-实型（浮点型）"><a href="#2-2-实型（浮点型）" class="headerlink" title="2.2 实型（浮点型）"></a><strong>2.2 实型（浮点型）</strong></h3><ul><li><p>单精度  float  4字节     7位有效      ；双精度  double  8字节    15-16</p></li><li><p>c++中默认输出6位有效数字</p></li><li><p>科学计数法：</p><pre class=" language-c++"><code class="language-c++">float f2 = 3e2;//3*10^2    cout << f2 << endl;//结果为300    float f3 = 3e-2;//3*0.1^2;    cout << f3 << endl;//结果为0.03    </code></pre><h3 id="2-3-字符型"><a href="#2-3-字符型" class="headerlink" title="2.3 字符型"></a><strong>2.3 字符型</strong></h3><p><code>char ch ='a' </code>用于显示单个字符</p><p><strong>注意：显示字符变量时，用单引号将字符括起来，不要用双引号</strong></p><p><strong>单引号只能有一个字符，不可以是字符串</strong></p><ul><li><p>c/c++中字符变量只占==一个字节==</p></li><li><p>字符型变量不是把字符本身放在内存中存储，而是将ASSCLL编码放入存储单元</p></li><li><p>字符型变量的创建方式</p></li><li><p>字符型变量对应ASCII编码</p><pre class=" language-c++"><code class="language-c++">//字符型变量对应的ASCII编码    cout << (int)ch << endl;//字符型强转成整型a---97A---65</code></pre></li></ul></li></ul><h3 id="2-4-转义字符"><a href="#2-4-转义字符" class="headerlink" title="2.4 转义字符"></a><strong>2.4 转义字符</strong></h3><ul><li>\n :换行    \t:水平制表（跳到下一个tab）  \：代表一个反斜线（可以输出更整齐）</li></ul><h3 id="2-5-字符串型"><a href="#2-5-字符串型" class="headerlink" title="2.5 字符串型"></a><strong>2.5 字符串型</strong></h3><pre class=" language-c++"><code class="language-c++">1、c语言字符串    //注意事项：  char  字符串名 []    //注意事项2：等号后面用双引号包含起来字符串    char str[] = "hello";    cout << str << endl;2、C++风格    //要包含一个头文件 #include<string>    string str2 = "hello";    cout << str2 << endl;</code></pre><h3 id="2-6-布尔类型bool"><a href="#2-6-布尔类型bool" class="headerlink" title="2.6 布尔类型bool"></a><strong>2.6 布尔类型bool</strong></h3><p>  <strong>代表真或假的值</strong></p><ul><li>有两个值  true–真（本质是1）   false–假（本质是0）</li><li>占一个字节大小</li></ul><pre class=" language-c++"><code class="language-c++">  //1、创建bool数据类型      bool flag = true;//true代表真 1      cout << flag << endl;      flag = false;//false代表假 0      cout << flag << endl;  //2、查看其内存空间      cout << "bool类型所占的内存空间：" << sizeof(flag) << endl;</code></pre><h3 id="2-7-数据的输入"><a href="#2-7-数据的输入" class="headerlink" title="2.7 数据的输入"></a><strong>2.7 数据的输入</strong></h3><p>  <strong>用于从键盘获取数据</strong>     <code>cin &gt;&gt; 变量</code></p><pre class=" language-c++"><code class="language-c++">1、整型    int a = 0;    cout << "请给整型变量a赋值：" << endl;    cin >> a;    cout << "整型输出a=" << a << endl;2、浮点型    float f = 3.14f;    cout << "请给浮点型型变量a赋值：" << endl;    cin >> f;    cout << "浮点型f输出f=" << f << endl;3、字符型    char ch = 'a';    cout << "请给字符型型变量a赋值：" << endl;    cin >> ch;    cout << "字符型ch输出f=" << ch << endl;4、字符串型    string str = "hello";    cout << "请给字符串型变量str赋值：" << endl;    cin >> str;    cout << "字符串型输出str=" << str << endl;4、布尔类型    bool flag = 0.5;    cout<< "bool flag = " << flag << endl;    cerr << "请给bool类型赋值" << endl;    cin >> flag;    cerr << "bool flag = " << flag << endl;</code></pre><ul><li><p>算数运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">术语</th><th align="center">示例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">/</td><td align="center">除</td><td align="center">10/5</td><td align="center">2</td></tr><tr><td align="center">%</td><td align="center">取余</td><td align="center">10%3;10%20</td><td align="center">1;10</td></tr><tr><td align="center">++</td><td align="center">前置递增</td><td align="center">a=2;b=++a</td><td align="center">a=3;b=3</td></tr><tr><td align="center">++</td><td align="center">后置递增</td><td align="center">a=2;b=a++</td><td align="center">a=3;b=2</td></tr><tr><td align="center">–</td><td align="center">前置递减</td><td align="center">a=2;b=–a</td><td align="center">a=1;b=1</td></tr><tr><td align="center">–</td><td align="center">后置递减</td><td align="center">a=2;b=a–</td><td align="center">a=1;b=2</td></tr></tbody></table><p><strong>两个小数不能做取模运算</strong>；<strong>只有整型变量才可以取模</strong></p></li><li><p>赋值运算符</p><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+=</td><td>加等于</td><td>a=0;a+=2//a=a+2</td><td>a=2</td></tr><tr><td>-=</td><td>减等于</td><td>a=5;a-=3//a=a-3</td><td>a=2</td></tr><tr><td>*=</td><td>乘等于</td><td>a=2;a*=2…</td><td>a=4</td></tr><tr><td>/=</td><td>除等于</td><td>a=4;a/=2…</td><td>a=2</td></tr><tr><td>%=</td><td>模等于</td><td>a=3;a%=2…</td><td>a=1</td></tr></tbody></table></li><li><p>逻辑运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">术语</th><th align="center">示例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">！</td><td align="center">非</td><td align="center">!a</td><td align="center">…</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">与</td><td align="center">a&amp;&amp;b</td><td align="center">同真则真，一假则假</td></tr><tr><td align="center">||</td><td align="center">或</td><td align="center">a||b</td><td align="center">一真即真，同假为假</td></tr></tbody></table><p><strong>c++中除了0都为真</strong></p><h2 id="三、程序流程结构（顺序、选择、循环）"><a href="#三、程序流程结构（顺序、选择、循环）" class="headerlink" title="三、程序流程结构（顺序、选择、循环）"></a>三、程序流程结构（顺序、选择、循环）</h2></li></ul><h3 id="3-1选择结构："><a href="#3-1选择结构：" class="headerlink" title="3.1选择结构："></a>3.1选择结构：</h3><h4 id="3-1-1-单行格式if语句"><a href="#3-1-1-单行格式if语句" class="headerlink" title="3.1.1 单行格式if语句"></a>3.1.1 单行格式if语句</h4><pre class=" language-c++"><code class="language-c++">`if(条件){条件满足执行的语句}`**后面不要加分号**```c++//选择结构  单行if语句    //用户输入分数，如果分数大于100，屏幕输出    //1、用户输入分数    int score = 0;    cout << "请输入一个分数" << endl;    cin >> score;    //2、打印    cout << "分数为：" << score << endl;    //3、判断分数是否大于600，如果大于则输出    if (score > 600)    {        cout << "恭喜你" << endl;    }```</code></pre><h4 id="3-1-2-多行格式if语句"><a href="#3-1-2-多行格式if语句" class="headerlink" title="3.1.2 多行格式if语句"></a>3.1.2 多行格式if语句</h4><pre class=" language-c++"><code class="language-c++"> ：`if(条件）{条件满足执行的语句}else{条件不满足执行的语句}````c++//选择结构  多行if语句    //用户输入分数，如果分数大于100，屏幕输出    //1、用户输入分数    int score = 0;    cout << "请输入一个分数" << endl;    cin >> score;    //2、打印    cout << "分数为：" << score << endl;    //3、判断分数是否大于600，如果大于则输出    if (score > 600)    {        cout << "恭喜你" << endl;    }    else    {        cout << "加油，别放弃" << endl;    }```</code></pre><h4 id="3-1-3-多条件的if语句"><a href="#3-1-3-多条件的if语句" class="headerlink" title="3.1.3 多条件的if语句"></a>3.1.3 多条件的if语句</h4><pre class=" language-c++"><code class="language-c++"> `if（条件1）{满足条件1执行} else if(条件2）{满足条件2执行}....else {条件不满足执行}````c++//选择结构  多条件if语句    //用户输入分数，如果分数大于600，输出A;    //如果分数大于500小于600，输出B;    //如果分数大于400小于500，输出C;    //1、用户输入分数    int score = 0;    cout << "请输入一个分数" << endl;    cin >> score;    //2、打印    cout << "分数为：" << score << endl;    //3、判断分数是否大于600，如果大于则输出    if (score > 600)    {        cout << "恭喜你:A" << endl;    }    else if (500<score)    {        cout << "恭喜你：B" << endl;    }    else if (400 < score )    {        cout << "恭喜你：C" << endl;    }    else    {        cout << "加油，别放弃" << endl;    }```</code></pre><h4 id="3-1-4-嵌套if"><a href="#3-1-4-嵌套if" class="headerlink" title="3.1.4 嵌套if"></a>3.1.4 嵌套if</h4><pre class=" language-c++"><code class="language-c++">```c++/*    -输入一个分数，根据分数判断    -分数大于600视为A，大于500视为B，大于400视为C，其余视为D    -在A中，大于650分A+,大于700分，视为A++    */    int score = 0;    cout << "请输入你的分数：" << endl;    cin >> score;    cout << "输入的分数为：" << score << endl;    if (score>600)    {        cout << "恭喜你：A" << endl;        if (score>700)        {            cout << "太棒了：A+++"<< endl;        }        else if (score>650)        {            cout << "很棒：A++"<< endl;        }        else        {            cout << "A+" << endl;        }    }    else if (score>500)    {        cout << "恭喜你：B"<< endl;    }    else if (score>400)    {        cout << "恭喜你:C" << endl;    }    else    {        cout << "别放弃，加油" << endl;    }```</code></pre><h4 id="小作业：三只小猪称体重"><a href="#小作业：三只小猪称体重" class="headerlink" title="小作业：三只小猪称体重"></a>小作业：三只小猪称体重</h4><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    //三只小猪称体重，判断哪只最重    //1、创建三只小猪    int num1 = 0;    int num2 = 0;    int num3 = 0;    //2、输入三只小猪的重量    cout << "请输入小猪A的重量" << endl;    cin >> num1;    cout << "请输入小猪B的重量" << endl;    cin >> num2;    cout << "请输入小猪C的重量" << endl;    cin >> num3;    cout << "小猪A的体重为：" << num1 << endl;    cout << "小猪B的体重为：" << num2 << endl;    cout << "小猪C的体重为：" << num3 << endl;    //3、进行比较    //先判断A和B    if (num1>num2)    {        if (num1 > num3)        {            cout << "小猪A最重" << endl;        }        else        {            cout << "小猪C最重" << endl;        }    }    else    {        if (num2 > num3)        {            cout << "小猪B最重" << endl;        }        else        {            cout << "小猪C最重" << endl;        }    }    system("pause");    return 0;}</code></pre><h4 id="3-1-5-三目运算符"><a href="#3-1-5-三目运算符" class="headerlink" title="3.1.5 三目运算符"></a>3.1.5 三目运算符</h4><p>  通过三目运算符实现简答判断:<code>表达式1 ?表达式2 : 表达式3</code></p><p>  <strong>如果表达式1为真,执行2,并返回2的值;否则执行3,并返回3的值</strong></p><pre class=" language-c++"><code class="language-c++">//三目运算符    //创建a,b,c    //a和b做比较，将最大的变量赋给c    int a = 8;    int b = 6;    int c = 12;    c = (a > b ? a : b);    cout << c << endl;    //c++中三目运算符返回的是变量，可以继续赋值    (a > b ? a : b) = 100;    cout << "a=" << a << endl;    cout << "b=" << b << endl;</code></pre><h4 id="3-1-6-switch语句"><a href="#3-1-6-switch语句" class="headerlink" title="3.1.6 switch语句"></a>3.1.6 switch语句</h4><p>  执行多条件分支语句</p><pre class=" language-c++"><code class="language-c++">switch(表达式){        case 结果1：执行语句;break;        case 结果1：执行语句;break;                ...        default:执行语句；break;}</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;int main(){    //switch语句    //给一个电影打分    //10 ~9  经典    //8 - 7 非常好    //6 - 5 一般    //5以下   烂片    //1、提示用户给电影评分    cout << "请给电影打分" << endl;    //2、用户开始打分    int score = 0;    cin >> score;    cout << "你输入的分数为：" << score << endl;    //3、根据用户输入的分数提示用户最后的结果    switch (score)    {    case 10:        cout << "经典电影" << endl;        break;//退出当前分支    case 9:        cout << "经典电影" << endl;        break;//退出当前分支    case 8:        cout << "非常好电影" << endl;        break;//退出当前分支    case 7:        cout << "非常好电影" << endl;        break;    default:        cout << "烂片" << endl;        break;    }    system("pause");    return 0;}</code></pre><p>  ==注1==：case里如果没有break,那么程序会一直执行</p><p>  ==if    switch   区别？：==</p><p>  //switch缺点，判断只能说是整型或者字符型，不可一是一个区间</p><p>  //switch优点，结构很清晰，执行效率高</p><p>###3.2 循环结构</p><p>####3.2.1 while循环</p><ul><li><p>只要循环为真，就执行循环语句<code>while(循环条件){循环语句}</code></p></li><li><p>写循环时避免死循环</p></li><li><p>添加随机数种子  避免随机数重复<br>==srand((unsigned int)time(NULL));且添加头文件====#include<ctime>==</ctime></p></li><li><p>==break;//可用改关键字退出循环==</p></li><li><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;#include<ctime>//时间头文件包int main(){    //添加随机数种子  避免随机数重复    srand((unsigned int)time(NULL));    //1、系统生成随机数    int num = rand() % 100 + 1;   // 生成0-99的随机数    生成1-100    //cout << num << endl;        //2、玩家进行猜测    int val = 0;//玩家输入的数据    while (1)    {        cin >> val;        //3、判断玩家的猜测        if (val > num)        {            cout << "猜大了" << endl;        }        else if (val < num)        {            cout << "猜小了" << endl;        }        else        {            cout << "猜对了" << endl;            break;//可用改关键字退出循环        }    }    //猜对，退出游戏    //猜错，提示猜的结果，过大或过小，重新返回第二步    system("pause");    return 0;}</code></pre><h4 id="3-2-2-do…while循环语句"><a href="#3-2-2-do…while循环语句" class="headerlink" title="3.2.2 do…while循环语句"></a>3.2.2 do…while循环语句</h4></li></ul><p><code>do{循环语句} while(循环条件)；先执行语句，再判断条件</code></p><ul><li>do…while和while的区别是do…while会先执行一次循环</li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;#include<ctime>//时间头文件包int main(){        int num = 0;    do    {        cout << num << endl;        num++;    } while (num < 10);    system("pause");    return 0;}        </code></pre><h4 id="案例：水仙花数"><a href="#案例：水仙花数" class="headerlink" title="案例：水仙花数"></a>案例：水仙花数</h4><ul><li><p>水仙花束数是一个三位数，它的每个位上的数字的3次幂之和为它本身，如1^3 + 2^3 + 3^3 = 153</p><p>用do….while语句，求出所有3位数中的水仙花数</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;#include<ctime>//时间头文件包int main(){    /*    1、将所有的三位数进行输出（100-999）；    2、找出三位数中所有的水仙花数    水仙花                153    获取个位            153%10=3          对数字取模于10可以获取到个位    获取十位            153/10=15         15%10=5    先整除于10，得到两位数，再取余得到个位数    获取百位            153/100=1         直接整除于100，获取百位    判断      个位^3 +十位^3 + 百位^3  =  自己    */    int num = 100;    do    {        int a = 0;//个        int b = 0;//十        int c = 0;//百        a = num % 10;        b = num / 10 % 10;        c = num / 100;        if (a*a*a+b*b*b+c*c*c ==num)        {            cout << num << endl;        }                num++;    } while (num < 1000);        system("pause");    return 0;}</code></pre></li></ul><h4 id="3-2-3-for循环"><a href="#3-2-3-for循环" class="headerlink" title="3.2.3 for循环"></a>3.2.3 for循环</h4><p>满足循环条件，执行循环语句：<code>for(起始表达式；条件表达式；末尾循环体){循环语句；}</code></p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    //for  循环    //从0^9    //第一种    for (int i = 0; i < 10; i++)    {        cout << i << endl;    }    //第二种    int i = 0;    for ( ; ;)    {        if (i>=10)        {            break;        }        cout << i << endl;        i++;    }    system("pause");    return 0;}</code></pre><ul><li>for循环中表达式，要用分号进行分隔</li><li>while,do…while,for都是开发中常用的循环，for较为清晰</li></ul><h4 id="小作业：敲桌子"><a href="#小作业：敲桌子" class="headerlink" title="小作业：敲桌子"></a>小作业：敲桌子</h4><p>从1开始数到数字100，如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    for (int i = 1; i <= 100; i++)    {        int a = 0;        int b = 0;        int c = 0;        a = i % 10;        b = i / 10;        c = i % 7;        if (a == 7 || b == 7 || c == 0)        {            cout << "敲桌子" << endl;        }        else        {            cout << i << endl;        }            }        system("pause");    return 0;} </code></pre><h4 id="3-2-4-嵌套循环"><a href="#3-2-4-嵌套循环" class="headerlink" title="3.2.4 嵌套循环"></a>3.2.4 嵌套循环</h4><p>在循环体中再嵌套一层循环，解决实际问题</p><p><strong>输出星图</strong>：</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    //利用嵌套循环实现星图    //打印一行星图    //i就近原则    //外层执行一次，内层执行一周    //外层循环    for (int i = 0; i < 10; i++)    {        //内层循环        for (int j = 0; j < 10; j++)        {            cout << "* ";        }        cout << endl;    }    system("pause");    return 0;} </code></pre><h4 id="嵌套循环案例：乘法口诀表"><a href="#嵌套循环案例：乘法口诀表" class="headerlink" title="嵌套循环案例：乘法口诀表"></a>嵌套循环案例：乘法口诀表</h4><img src="/2021/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/1.png" class=""><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    ///乘法口诀表    //打印行数    for (int i = 1; i < 10; i++)    {        //cout << i << endl;        for (int j = 1; j <= i; j++)//列数的表示方法        {            cout << j<<"*"<<i<<"="<<j*i<<"  ";//行数的表示方法                    }        cout << endl;    }    system("pause");    return 0;} </code></pre><h3 id="3-3-跳转语句"><a href="#3-3-跳转语句" class="headerlink" title="3.3 跳转语句"></a>3.3 跳转语句</h3><h4 id="3-3-1-break语句"><a href="#3-3-1-break语句" class="headerlink" title="3.3.1 break语句"></a>3.3.1 break语句</h4><p>==用于跳出选择结构或者循环结构==</p><p>使用时机：</p><ul><li>出现在switch条件语句中，作用是终止case并跳出switch</li><li>出现在嵌套语句中，作用是跳出当前循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    //break的使用时机    //1、出现在switch    /*cout << "请选择副本难度"<<endl;    cout << "1、普通"<<endl;    cout << "2、中的"<<endl;    cout << "3、困难"<<endl;    int seclet = 0;    cin >> seclet;    switch (seclet)    {    case 1:        cout << "普通" << endl;        break;    case 2:        cout << "中等" << endl;        break;    case 3:        cout << "困难" << endl;        break;    default:        break;    }*/    //2、出现在循环语句    //for (int i = 0; i < 10; i++)    //{    //    //如果i等于5，退出循环，不再打印    //    if (i==5)    //    {    //        break;//退出循环    //    }    //    cout << i << endl;    //}    //3、出现在嵌套循环中    for (size_t i = 0; i < 10; i++)    {        for (int j = 0; j < 10; j++)        {            if (j==5)            {                break;//退出内层循环            }            cout << "* ";        }        cout << endl;            }    system("pause");    return 0;} </code></pre><h4 id="3-2-2-continue-语句"><a href="#3-2-2-continue-语句" class="headerlink" title="3.2.2 continue 语句"></a>3.2.2 continue 语句</h4><p>在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一层循环</p><p><strong>与break的区别</strong>：</p><p>==continue执行到本行就不再执行后面了，然后再一次循环==</p><p>==break直接是跳出循环了==</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    //continue语句    for (int i = 1; i <= 100; i++)    {        //如果是基数输出，偶数不输出        if (i%2==0)        {            continue;//偶数这些数就不再往下输出了                     //要与continue区分一下                     //可以筛选条件，执行到此就不再向下执行了                    //break直接退出了            }        cout << i << endl;    }        system("pause");    return 0;} </code></pre><p><strong>continue并不会使整个循环终止，而break会跳出循环</strong></p><h4 id="3-2-3-goto语句"><a href="#3-2-3-goto语句" class="headerlink" title="3.2.3 goto语句"></a>3.2.3 goto语句</h4><p>可以无条件跳转语句：<code>goto 标记；</code></p><p><strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</strong></p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    //goto语句；    cout << "1、***" << endl;    cout << "2、***" << endl;    goto flag;    cout << "3、***" << endl;    cout << "4、***" << endl;    flag:    cout << "5、***" << endl;    system("pause");    return 0;}</code></pre><h2 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h2><p>数组就是一个存放了相同类型数据元素的一个集合</p><ul><li>==数组中的每个数据元素都是相同的数据类型==</li><li>==数组是由连续的内存位置组成的==</li></ul><h3 id="4-1-一维数组"><a href="#4-1-一维数组" class="headerlink" title="4.1 一维数组"></a>4.1 一维数组</h3><h4 id="4-1-1-一维数组的定义三种方式"><a href="#4-1-1-一维数组的定义三种方式" class="headerlink" title="4.1.1 一维数组的定义三种方式"></a>4.1.1 一维数组的定义三种方式</h4><ul><li><p>1.<code>数据类型   数组名[数组长度]；</code></p></li><li><p>2.<code>数据类型   数组名[数组长度] = {值1,2,3...}</code></p></li><li><p>3.<code>数据类型   数组名[ ] ={值1,2,3...}</code></p></li><li><p>初始化数据的时候，没有全部填写完，会用0来填补剩余数据</p></li><li><p>定义数组的时候，必须有一个初始的长度</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    /*+1.`数据类型   数组名[数组长度]；`        + 2.`数据类型   数组名[数组长度] = { 值1,2,3... }`    + 3.`数据类型   数组名[] = { 值1,2,3... }`*/    //+1.`数据类型   数组名[数组长度]；`    /*int arr[5];    arr[0] = 10;    arr[1] = 10;    arr[2] = 10;    arr[3] = 10;    arr[4] = 10;    cout << arr[0] << endl;*/    //利用循环，输出数组中的元素    /*int arr[5] = { 1,2,3,4,5 };    for ( int i = 0; i < 5; i++)    {        cout << arr[i] << endl;    }*/    //数据类型   数组名[] = { 值1,2,3... }    int arr2[] = { 1,2,3,4,5,6 };    for (int i = 0; i < 6; i++)    {        cout << arr2[i] << endl;    }    system("pause");    return 0;}</code></pre><h4 id="4-1-2-一维数组数组名"><a href="#4-1-2-一维数组数组名" class="headerlink" title="4.1.2 一维数组数组名"></a>4.1.2 一维数组数组名</h4><ul><li><p>可以统计真个数组在内存中的长度 sizeof(arr)</p></li><li><p>可以获取数组在内存中的首地址  </p></li><li><p>数组名是一个常量，不可以进行赋值操作</p></li><li><p>数组名arr = 首地址 = 第一个元素的地址&amp;arr[0]</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>int main(){    //1、可以统计真个数组在内存中的长度  所占内存大小    int arr[] = { 1,2,3 };    cout << "整个数组所占的内存空间为："<<sizeof(arr) << endl;//一个整型是4个字节    cout << "每个所占大小" << arr[0] << endl;    cout << "数组中的元素个数为：" << sizeof(arr) / sizeof(arr[0]) << endl;    //2、可通过数组名查看数组的首地址    cout << "数组的首地址为：" << (int)arr << endl;//转换成了10进制    for (int i = 0; i < 3; i++)    {        cout << "数组中第" << i << "个元素的地址为：" << (int)&arr[i] << endl;    }    //数组名是一个常量，不可以进行赋值操作    system("pause");    return 0;}</code></pre></li></ul></li></ul><h4 id="案例1：五只小猪称体重"><a href="#案例1：五只小猪称体重" class="headerlink" title="案例1：五只小猪称体重"></a>案例1：五只小猪称体重</h4><pre><code>在一个数组中记录了5只小猪的体重，如 int arr[]={300,350,200,400,250}找出并打印最重的小猪的体重```c++#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    //1、创建5只小猪    int arr[5] = { 300,350,200,400,250 };    //2、从数组中找出最大值    int max = 0;    for (int i = 0; i &lt; 5; i++)    {        if (max &lt; arr[i])        {            max = arr[i];        }            }    //打印最大值    cout &lt;&lt; "最重的小猪体重为："&lt;&lt;max&lt;&lt; endl;    system("pause");    return 0;}```</code></pre><h4 id="案例2：数组元素逆置"><a href="#案例2：数组元素逆置" class="headerlink" title="案例2：数组元素逆置"></a>案例2：数组元素逆置</h4><p>声明一个5个元素的数组，并将元素逆置</p><img src="/2021/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/2.png" class=""><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;int main(){    //int start = 0;起始元素下标    //int end = sizeof(arr)/sizeof(arr[0])-1  //末尾元素下标    //法1    //int arr[] = { 4,2,5,3,10};    //    //for (int i = 4; i >=0 ; i--)    //{    //    cout << arr[i] << endl;    //}    //法2    int arr[] = { 4,2,5,3,10 };    for (int i = 0; i < 5; i++)    {        cout << arr[i] << endl;    }    //1 记录起始下标的位置    //2 记录结束下标的位置    //3 起始下标与结束下标元素互换    //4 起始位置++   结束位置--    //5 循环执行1，直到起始位置大于等于结束位置    int start = 0;    int end = sizeof(arr) / sizeof(arr[0]) - 1;    while (start<end)    {    int temp = arr[start];    arr[start] = arr[end];    arr[end] = temp;    //下标更新    start++;    end--;    }    cout << "逆置后的元素为：" << endl;    for (int i = 0; i < 5; i++)    {        cout << arr[i] << endl;    }    system("pause");    return 0;}</code></pre><h4 id="4-1-2-冒泡排序"><a href="#4-1-2-冒泡排序" class="headerlink" title="4.1.2 冒泡排序"></a>4.1.2 冒泡排序</h4><ul><li>比较相邻的元素，如果第一个 比第二个大，就交换</li><li>对每一对相邻元素做相同的工作，执行完毕后，找到一个最大值</li><li>重复以上的步骤，每次次数-1，直到不需要比较</li><li>排序总轮数 = 元素个数 - 1</li><li>每轮对比次数 = 元素个数 - 排序轮数 - 1</li></ul><img src="/2021/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/3.png" class=""><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;int main(){    //利用冒泡排序实现升序序列    int arr[] = { 1,0,6,3,5,2,10,7,8 };    cout << "排序前：" << endl;    for (int i = 0; i < 9; i++)    {        cout << arr[i] << " ";    }    cout << endl;    //开始冒泡排序    //总共排序的轮数为 元素个数-1    for (int i = 0; i < 9-1; i++)    {        //内层循环对比  每轮对比次数=元素个数-当前排序轮数-1        for (int  j = 0; j < 9-i-1; j++)        {            //如果第一个数字比第二个数字大，交换两个数字            if (arr[j] > arr[j + 1])            {                int temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            }        }    }    //打印排序后    cout << "排序后：" << endl;    for (int i = 0; i < 9; i++)    {        cout << arr[i] << " ";    }    system("pause");    return 0;}</code></pre><h3 id="4-2-二维数组"><a href="#4-2-二维数组" class="headerlink" title="4.2 二维数组"></a>4.2 二维数组</h3><p>在一维数组上，多加一个维度</p><h4 id="4-2-1二维数组的定义方式"><a href="#4-2-1二维数组的定义方式" class="headerlink" title="4.2.1二维数组的定义方式"></a>4.2.1二维数组的定义方式</h4><ul><li><p><code>数据类型     数组名[行数] [列数];</code></p></li><li><p><code>数据类型     数组名[行数] [列数] = {{数据1，数据2},{数据3，数据4}，...};`+ `数据类型     数组名[行数] [列数] ={数据1，数据2，数据3，数据4}；`+ `数据类型     数组名[ ] [列数] ={数据1，数据2，数据3，数据4}`+ ==第二种更加直观，提高代码的可读性==+ **定义的时候，可以省略行数 ，但是不可以省略列数**#### 4.2.2 二维数组名称+ 查看二维数组所占内存空间+ 获取二维数组首地址+ ==二维数组的首地址arr  ==  第一行的首地址arr[0] ==第一行的第一个元素&amp;arr[0] [0]==```c++  #include<iostream>  using namespace std;    int main()  {  //二维数组名称用途    //1、可以查看内存空间大小  int arr[2][3] =   {  {1,2,3},  {4,5,6}  };  cout &lt;&lt; "内存空间大小为" &lt;&lt; sizeof(arr) &lt;&lt; endl;  cout &lt;&lt; "二维数组的第一行所占内存空间为：" &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;  cout &lt;&lt; "二维数组的第一个元素所占内存空间为：" &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;  cout &lt;&lt; "二维数组一共有" &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; "行" &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; "列" &lt;&lt; endl;  //2、可以查看二维数组的首地址  cout &lt;&lt; "二维数组的首地址为：" &lt;&lt; (int)arr &lt;&lt; endl;  cout &lt;&lt; "二维数组第一行的首地址为：" &lt;&lt; (int)arr[0] &lt;&lt; endl;  cout &lt;&lt; "二维数组第一行中第一个元素的首地址为：" &lt;&lt; (int)&amp;arr[0][0] &lt;&lt; endl;  cout &lt;&lt; "二维数组第二行的首地址为：" &lt;&lt; (int)arr[1] &lt;&lt; endl;  system("pause");  return 0;  }```#### 案例：考试成绩统计有三名同学（张三、李四、王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩|      | 语文 | 数学 | 英语 || ---- | ---- | ---- | ---- || 张三 | 100  | 100  | 100  || 李四 | 90   | 50   | 100  || 王五 | 60   | 70   | 80   |```c++#include<iostream>using namespace std;#include<string>int main(){//1、创建二维数组，3行3列//2、统计考试成绩，让每行的三列相加int arr[3][3] = {{100,100,100},{90,50,100},{60,70,80}};string names[3] = { "张三","李四","王五" };for (int i = 0; i &lt; 3; i++){int sum = 0;//统计分数综合for (int j = 0; j &lt; 3;j++ ){sum += arr[i][j];}cout &lt;&lt; names[i] &lt;&lt; "的总分为：" &lt;&lt; sum ;cout &lt;&lt; endl;}system("pause");return 0;}```## 五、函数将一段经常使用的代码封装起来，减少重复代码，一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能### 5.1 函数的定义函数的定义一般有5个步骤：+ 返回值类型:一个函数可以返回一个值+ 函数名：给函数起个名字+ 参数列表：使用函数时，传入的数据+ 函数体语句：花括号内的代码，函数内需要执行的语句+ return 表达式：和返回值类型挂钩，函数执行完后，返回相应的数据```c++返回值类型  函数名（参数列表）{函数体语句return表达式}```**实现一个加法函数，功能为传入两个整型数据，计算数据相加的结果，并且返回**1、返回值类型                     int2、函数名                            add3、参数列表(==形参==)       （int num1,int num2）4、函数体语句             int sum = num1+num25、return 表达式            return  sum;```c++//加法函数，实现两个整型相加，并将结果进行返回//返回值类型；函数名；参数列表；函数体语句；return表达式int add(int num1, int num2){int sum = num1 + num2;return sum;}```### 5.2 函数的调用`函数名（参数）`+ 当调用函数的时候   实参传递给形参+ 函数定义里的小括号称为形参，函数调用时传入的参数称为实参### 5.3 值传递+ 值传递：指函数调用时实参将数值传入给形参+ ==值传递时，如果形参发生变化，并不会影响实参==### 5.4 函数的常见样式+ 无参无返+ 有参无返+ 无参有返+ 有参有返```c++#include<iostream>using namespace std;#include<string>//函数产检样式//+ 无参无返void test01(){cout &lt;&lt; "这是第一个例子" &lt;&lt; endl;}//+ 有参无返void test02(int a){cout &lt;&lt; "这是第二个案例：" &lt;&lt; a &lt;&lt; endl;}//+ 无参有返int test03(){cout &lt;&lt; "这是第三个程序" &lt;&lt; endl;return 1000;}//+ 有参有返int test04(int a){cout &lt;&lt; "这个是04：" &lt;&lt; a &lt;&lt; endl;return a;}int main(){//1函数调用test01();//2函数调用test02(100);//3函数调用int c = test03();cout &lt;&lt; "C=:" &lt;&lt; c &lt;&lt; endl;//函数调用test04(10);system("pause");return 0;}```### 5.5 函数的声明告诉编译器函数名称及如何调用函数，函数的实际主体可单独定义+ ==函数的声明可以多次，但函数的定义只有一次==+ ==自定义函数在主函数之后时需要声明==+ ==函数声明方式：int   max(int a,int b);==### 5.6 函数的分文件编写让代码结构更加清晰，函数分文件编写一般有4个步骤+ 创建后缀名为.h的头文件+ 创建后缀名为.cpp的源文件+ 在头文件中写函数的声明     `#include<iostream>、using namespace std;也要写上去 +函数声明`+ 在源文件中写函数的定义  为了与头文件配套，写一个自定义头文件，如：`#include "swap.h"`+ 在主文件中添加上创建的自定义头文件,如`#include"swap.h"`## 六、指针**作用：可以通过指针间接访问内存**+ 内存编号是从0开始记录的，一般用十六进制数字表示+ 可以利用指针变量保存地址### 6.1 指针变量的定义和使用  语法 :  `数据类型 * 变量名；`+ 可以使用指针来保存一个地址；简单来说，指针就是一个地址+ 通过p找到a的内存，通过*p(解引用)修改a的内存  ```c++  #include<iostream>  using namespace std;      int main()  {   int a = 10;  //1、定义指针  //指针定义的语法  数据类型 * 指针变量  int * p;  //让指针记录变量a的地址  p = &amp;a;  cout &lt;&lt; "指针p为：" &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; "a的地址为：" &lt;&lt; &amp;a &lt;&lt; endl;    //2、使用指针  //可以通过解引用的方式来找到指针指向的内存  //指针前 + *代表解引用，找到指针指向的内存中的数据  *p = 1000;//通过p找到a的内存，通过*p修改a的内存  cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;  cout &lt;&lt; "*p = " &lt;&lt; *p &lt;&lt; endl;      system("pause");  return 0;  }  ```### 6.2 指针所占内存空间**指针也是一种数据类型**    如   int*  就是一种数据类型  可将对象强转成指针类型+ 32位操作系统下，占用4个字节空间；64位下，占用8个字节空间（所有类型都是）+ 在32位操作系统下，指针占用4个字节空间大小，不管什么数据类型+ 在64位操作系统下，指针占用8个字节空间大小### 6.3 空指针和野指针**空指针**：指针变量指向内存中编号为0的空间**用途**：初始化指针变量**注意**：空指针指向的内存是不可访问的空指针：```c++#include<iostream>using namespace std;int main(){ //空指针//1、空指针用于给指针变量进行初始化int * p = NULL;//2、空指针是不可以进行访问的//0 - 255之间的内存编号是系统占用的，因此不可以访问 *p = 100;system("pause");return 0;}```野指针：指针变量指向非法的内存空间```c++int main(){ //野指针//在程序中，避免出现野指针int * p = (int *)0x1100;//没有权利操控的指针//访问野指针报错cout &lt;&lt; *p &lt;&lt; endl;system("pause");return 0;}```**空指针和野指针都不是我们申请的空间，因此不要访问**### 6.4 const 修饰指针const修饰指针的三种情况：+ const修饰指针  --- 常量指针  + const int *p = &amp;a  {% asset_img 4.png %}```c++int main(){ int a = 10;int b = 20;const int * p = &amp;a;//常量指针：指针的指向可以修改，但指针指向的值不可以修改cout &lt;&lt; "第一次p的地址为:" &lt;&lt; p &lt;&lt; endl;    //输出为1个地址cout &lt;&lt; "第一次p的值为：" &lt;&lt; *p &lt;&lt; endl;   //输出为10p = &amp;b;cout &lt;&lt; "第二次p的地址为:" &lt;&lt; p &lt;&lt; endl;    //输出为1个地址   地址改变了cout &lt;&lt; "第二次p的值为：" &lt;&lt; *p &lt;&lt; endl;    //输出20*p = 30;//报错，指针指向的值不能修改system("pause");return 0;}   总结：p为指针变量为1个地址   *p为解引用，为一个指针所指向内存空间的值```+ const修饰常量  ---  指针常量  + int * const p = &amp;a  + 指针的指向不可以修改，但指针指向的值可以修改{% asset_img 5.png %}+ const 即修饰指针，又修饰常量  + const int * const p = &amp;a;  + 指针的指向和指针指向的值都不可以修改{% asset_img 6.png %}==记忆方法==+ 名字：const(常量)  int * p(指针)对应着记+ 用途：const 后面跟 p   ----- 指针常量：指向(p)不能修改  ​const 后面跟 *p ----- 常量指针：指针指向的值( * p)不能被修改   ```c++int main(){ //2、const修饰常量 //指针常量//指针的指向不可以修改，指针指向的值可以修改int a = 10;int b = 20;int * const p = &amp;a;*p = 30;//正确//p = &amp;b;//错误,指针的指向不可以改//3、const 修饰指针和常量const int * const p2 = &amp;a;//*p2 = 100;//错误//p2 = &amp;b;//错误system("pause");return 0;}```### 6.5 指针和数组利用指针访问数组中的元素```c++#include<iostream>using namespace std;int main(){ //指针和数组//利用指针访问数组中的元素int arr[] = { 1,2,3,3,6,5,4,20,45,12 };cout &lt;&lt; "第一个元素为：" &lt;&lt; arr[0] &lt;&lt; endl;int * p = arr;cout &lt;&lt; "利用指针访问的第一个值为" &lt;&lt; *p &lt;&lt; endl;p++;//指针向后偏移4个字节cout &lt;&lt; "利用指针访问的第二个元素的值为" &lt;&lt; *p &lt;&lt; endl;cout &lt;&lt; "利用指针遍历数组" &lt;&lt; endl;for (int i = 0; i &lt; 10;i++){cout &lt;&lt; *p &lt;&lt; endl;p++;}system("pause");return 0;}```### 6.6 指针和函数利用指针做函数参数，可以修改实参的值```c++#include<iostream>using namespace std;void swap01(int a, int b){int temp = a;a = b;b = temp;cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;}void swap02(int *p1, int *p2){int temp = *p1;*p1 = *p2;*p2 = temp;cout &lt;&lt; "a=" &lt;&lt; *p1 &lt;&lt; endl;cout &lt;&lt; "b=" &lt;&lt; *p2 &lt;&lt; endl;}int main(){ //实现两个数字进行交换//指针和函数//1、值传递//值传递改变不了实参int a = 10;int b = 20;swap01(a,b);cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;//2、地址传递//地址传递可以修改实参swap02(&amp;a, &amp;b);cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;system("pause");return 0;}```+ ==p表示指针，对应地址；*p对应解引用，对应指针指向的内存空间的值==+ ==需要改变实参用地址传递，不需要改变实参用值传递==### 6.7 指针、数组、函数案例**案例：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序+ 为函数传递数组时，实际上传递的是指向数组首元素的指针，因此不能拷贝数组，所以无法以值传递的方式使用数组参数+ 之前通过地址传递改变单个数的值，现在通过头元素地址修改整个数组的值+ *的第一种用途是和数据类型组合来定义指针，第二种用途是解引用+ ==C++编译器把arr[j]这个表达式看做是*(arr+1);比如加1，增加的值等于指向类型占用的字节数，对应的地址就会做出调整，跟之前的P++一个道理==+ 指针做形参改变实参```c++#include<iostream>using namespace std;//冒泡排序//参数1  数组的首地址   参数2   数组长度void paixu(int *arr,int len)//数组可以理解为一组指针，编译器在编译时会把数组当做指针来看//*arr  可以换为 arr[]{for (int i = 0; i &lt; len-1; i++){for (int j = 0; j &lt; len-i-1; j++){if (arr[j]&gt;arr[j+1]){int temp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = temp;}}}}//打印数组void printarray(int *arr,int len){for (int  i = 0; i &lt; len; i++){cout &lt;&lt; arr[i] &lt;&lt; endl;}}int main(){//1、创建一个数组int arr[11] = { 2, 3, 8, 5, 6, 4, 7, 10, 9, 4, 6 };//数组长度int len = sizeof(arr) / sizeof(arr[0]);//创建一个函数，实现冒泡paixu(arr, len);//3、打印排序后的数组printarray(arr, len);system("pause");return 0;}```## 七、结构体结构体属于用户自定义的数据类型，允许用户存储不同的数据类型### 7.1 结构体定义与使用语法：`struct 结构体名 {结构体成员列表 }；`通过结构体创建变量的方式有三种：+ struct   结构体名  变量名+ struct   结构体名  变量名 = {成员1值，成员2值...}+ 定义结构体时顺便创建变量==结构体创建时 struct 不可以省略====结构体定义的时候  struct可以省略====结构体变量利用操作符“.”访问成员==```c++#include<iostream>using namespace std;#include<string>//1、创建学生的数据类型：学生包括（姓名，年龄，分数）//自定义数据类型，一些类型集合组成的一个类型//语法  struct  类型名称{成员列表}struct student{//成员列表//姓名 string name;//年龄int age;//分数int score;}s3;//顺便创建结构体变量int main(){//2、通过学生类型创建具体学生//2.1 struct student s1 //struct关键字可以省略struct student s1;//给属性赋值，通过.访问结构体变量中的属性s1.name = "张三";s1.age = 24;s1.score = 150;cout &lt;&lt;"姓名："&lt;&lt; s1.name&lt;&lt;"年龄："&lt;<s1.age<<"分数："<<s1.score <<="" endl;="" 2.2="" struct="" student="" s2="{...}" "李四",24,150="" &#125;;="" cout="" "姓名："="" s2.name="" "年龄："="" s2.age="" "分数："="" s2.score="" 2.3="" 在定义结构体时顺便创建结构体变量="" s3.name="王五" ;="" s3.age="25;" s3.score="150;" system("pause");="" return="" 0;="" &#125;="" ```="" ###="" 7.2="" 结构体数组="" 将自定义的结构体放入数组中方便维护="" 语法：`struct="" 结构体名="" 数组名[元素个数]="{{}，{}，...{}}</code"><!--"姓名："<<--></s1.age<<"分数："<<s1.score></string></iostream></iostream></iostream></iostream></iostream></iostream></iostream></string></iostream></string></iostream></iostream></code></p></li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>//结构体数组//1、定义一个结构体struct student{    //姓名    string name;    //年龄    int age;    //分数    int score;};int main(){    //2、创建一个结构体数组    student stu[3] =     {        {"张三",18,100},        {"李四",18,100},        {"王五",18,100}    };    //3.给结构体数组中的元素赋值    stu[2].name = "许六";    stu[2].age = 25;    stu[2].score = 150;    //4.遍历结构体数组    for (int i = 0; i < 3; i++)    {        cout << " 姓名是：" << stu[i].name << " 年龄是：" << stu[i].age << " 分数是：" << stu[i].score << endl;    }    system("pause");    return 0;}</code></pre><h3 id="7-3-结构体指针"><a href="#7-3-结构体指针" class="headerlink" title="7.3 结构体指针"></a>7.3 结构体指针</h3><p>作用：通过指针访问结构体中的成员</p><p>==利用操作符 -&gt; 可通过结构体指针访问结构体属性==</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>//结构体指针//定义一个学生的结构体struct student{    string name;    int age;    int score;};int main(){    //创建学生的结构体变量    student s = { "张三",25,150 };    student * p = &s;    //通过指针指向结构体变量中的数据    //通过结构体指针访问结构体中的属性，用“->”    cout << " 姓名：" << p->name << " 年龄：" << p->age << " 分数：" << p->score << endl;    system("pause");    return 0;}</code></pre><h3 id="7-4-结构体嵌套结构体"><a href="#7-4-结构体嵌套结构体" class="headerlink" title="7.4 结构体嵌套结构体"></a>7.4 结构体嵌套结构体</h3><p>作用：结构体中的成员可以使另一个结构体作为成员来解决实际问题</p><p>如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><img src="/2021/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/05/11/c-xue-xi-1.0-chu-ji-bian-cheng/7.png" class=""><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>//定义一个学生的结构体struct student{    string name;    int age;    int score;};//定义一个老师的结构体struct teacher{    int id;    string name;    int age;    struct student stu;};int main(){    //结构体嵌套结构体    //创建老师的结构体    teacher t;    t.id = 1000;    t.name = "老张";    t.age = 40;    t.stu.name = "张三";    t.stu.age = 25;    t.stu.score = 150;        cout << " 老师的姓名为：" << t.name << " 工号：" << t.id << "年龄 ：" << t.age         <<" 老师辅导的学生的姓名："<<t.stu.name<<"学生的年龄："<<t.stu.age<<" 学生的成绩为："<<t.stu.score << endl;    system("pause");    return 0;}</code></pre><h3 id="7-5-结构体做函数参数"><a href="#7-5-结构体做函数参数" class="headerlink" title="7.5 结构体做函数参数"></a>7.5 结构体做函数参数</h3><p>作用：将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>//定义学生结构体struct student{    string name;    int age;    int score;};//打印学生信息//1、值传递void printf_s1(struct student c){    c.age = 100;//实参并未改变    cout << "子函数1中  名字：" << c.name << " 年龄：" << c.age << " 分数：" << c.score << endl;}//2、地址传递void printf_s2(struct student *p){    p->age = 50;//实参发生了改变    cout << "子函数2中  名字：" << p->name << " 年龄：" << p->age << " 分数：" << p->score << endl;}int main(){    //结构体做函数参数    //将学会说呢过传入到一个参数中，打印学生身上的所有信息    //创建一个结构体变量    student s = { "张三",24,150 };    student s2 = { "李四",24,150 };    printf_s1(s);    printf_s2(&s2);    cout << "main函数中打印的结果 姓名：" << s2.name << " 年龄：" << s2.age << " 成绩："<<s2.score << endl;    system("pause");    return 0;}</code></pre><p>==如果不想修改主函数中的数据，用值传递，反之用地址传递==</p><h3 id="7-6-结构体中const使用场景"><a href="#7-6-结构体中const使用场景" class="headerlink" title="7.6 结构体中const使用场景"></a>7.6 结构体中const使用场景</h3><p>作用：用const来防止误操作</p><p>==将函数中的形参改为指针后，可以减少内存空间，一个指针占4个内存，而且不会赋值新的副本出来==</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;#include<string>//const的使用场景struct student{    string name;    int age;    int score;};//将函数中的形参改为指针后，可以减少内存空间，一个指针占4个内存//而且不会赋值新的副本出来void printf1(const student *s){    //值传递拷贝出很多数据   占用内存较大    //改为了地址传递    //s->age = 150;//加入const之后，一旦有修改的操作就会报错，可以防止我们的误操作    cout << "函数打印 姓名：" << s->name << " 年龄：" << s->age << " 成绩：" << s->score << endl;}int  main(){    //创建结构体变量    struct student s = { "张三",25,150 };    //通过函数来打印结构体变量的信息    printf1(&s);    system("pause");    return 0;}</code></pre><h3 id="7-7-结构体案例1"><a href="#7-7-结构体案例1" class="headerlink" title="7.7 结构体案例1"></a>7.7 结构体案例1</h3><p>老师和学生做毕设，一个老师带5个，共有3名老师：</p><p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员，学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值，最终打印出老师的数据以及老师所带学生的数据。</p><ul><li>学会随机函数的使用方法</li><li>学会字符串拼接的方法</li><li><code>fuzhi(struct teacher t[],int len) t[]</code>可替换为<code>*t、*a</code></li><li>==结构体嵌套时，若一级为数组，函数形参也用数组形式，若一级为单个，则可用指针形式==</li><li>数组与指针都可互相取值</li><li></li></ul><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>#include<ctime>//时间头文件包using namespace std;//学生的结构体struct student{    string name;    int age;    int score;};//老师的结构体的定义struct teacher{    string name;    struct student stu[5];};//给老师和学生赋值的函数void fuzhi(struct teacher t[],int len){    string nameseed = "ABCDE";    //给老师开始赋值    for (int  i = 0; i < len; i++)    {        t[i].name = "teacher_";        t[i].name += nameseed[i];        //通过循环给每名老师所带的学生赋值        for (int j = 0; j < 5; j++)        {            t[i].stu[j].name = "student_";            t[i].stu[j].name += nameseed[j];            int random = rand() % 61+40;//0-60   40-100            t[i].stu[j].score = random;        }            }    }//打印所有信息void shuchu(struct teacher a[],int len){    for (int i = 0; i < len; i++)    {        cout << "老师姓名：" << a[i].name << endl;        for (int j = 0; j < 5; j++)        {            cout << "\t学生姓名：" << a[i].stu[j].name << "分数为：" << a[i].stu[j].score << endl;        }            }}int main(){    //添加随机数种子    srand((unsigned int)time(NULL));    //1.创建3名老师的数组    teacher t[3];    //2.通过函数给3名老师的信息复制，并给老师所带的学生的信息复制    int len = sizeof(t) / sizeof(t[0]);    fuzhi(t, len);    //3.打印所有老师及所带的学生的信息    shuchu(t, len);    system("pause");    return 0;}</code></pre><h3 id="7-8-结构体案例2"><a href="#7-8-结构体案例2" class="headerlink" title="7.8 结构体案例2"></a>7.8 结构体案例2</h3><p>设计一个英雄结构体，包括姓名，年龄，性别；创建结构体数组，数组中存放5名英雄。通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p><p>五名英雄信息如下：</p><pre class=" language-c++"><code class="language-c++">{"刘备"，23，"男"}，{"关羽"，22，"男"},{"张飞"，28，"男"},{"赵云"，21，"男"},{"貂蝉"，19，"女"},</code></pre><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;//1、设计英雄结构体struct hero{    string name;    int age;    string sex;};//3、对数组进行排序，按照年龄进行升序排序void mp(struct hero a[],int len){    for (int i = 0; i < len-1; i++)    {       for (int j = 0; j < len-i-1; j++)       {           //           if (a[j].age>a[j+1].age)           {               struct hero temp = a[j];               a[j] = a[j + 1];               a[j + 1] = temp;           }                  }           }    }//4、将排序后的英雄进行输出void shuchu(struct hero s[],int len){    for (int i = 0; i < len; i++)    {        cout << "姓名：" << s[i].name << " 年龄：" << s[i].age << " 性别：" << s[i].sex << endl;    }    }int main(){    //2、创建数组存放5名英雄        hero h[5] =        {            {"刘备", 23,             "男"},            {"关羽", 22,             "男"},            {"张飞", 28,             "男"},            {"赵云", 21,             "男"},            {"貂蝉", 19,             "女"},        };        mp(h, 5);        shuchu(h, 5);    system("pause");    return 0;}</code></pre><ul><li>结构体交换是可以整体交换的</li></ul><h2 id="通讯录管理系统"><a href="#通讯录管理系统" class="headerlink" title="通讯录管理系统"></a>通讯录管理系统</h2><p>通讯录是一个可以记录亲人、好友信息的工具，系统中需要实现的功能如下：</p><ul><li><p>添加联系人：像通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多纪录1000人</p></li><li><p>显示联系人：显示通讯录中所有联系人信息</p></li><li><p>删除联系人：按照姓名进行删除指定联系人</p></li><li><p>查找联系人：按照姓名查看指定联系人信息</p></li><li><p>修改联系人：按照姓名重新修改指定联系人</p></li><li><p>清空联系人：情况通讯录中所有信息</p></li><li><p>退出通讯录：推出当前使用的通讯录</p></li></ul><h3 id="1、菜单功能"><a href="#1、菜单功能" class="headerlink" title="1、菜单功能"></a>1、菜单功能</h3><ul><li>封装函数显示该界面，如<code>void showMenu()</code></li><li>在main函数中调用封装好的函数</li></ul><pre class=" language-c++"><code class="language-c++">void showMenu(){    cout << "**************************" << endl;    cout << "*****  1、添加联系人  *****" << endl;    cout << "*****  2、显示联系人  *****" << endl;    cout << "*****  3、删除联系人  *****" << endl;    cout << "*****  4、查找联系人  *****" << endl;    cout << "*****  5、修改联系人  *****" << endl;    cout << "*****  6、清空联系人  *****" << endl;    cout << "*****  7、退出联系人  *****" << endl;    cout << "**************************" << endl;}</code></pre><h3 id="2、退出功能"><a href="#2、退出功能" class="headerlink" title="2、退出功能"></a>2、退出功能</h3><p>思路：根据用户不同的选择，进入不同的功能，可以选择switch分支结构，将震哥哥架构进行搭建，当用户选择0时，执行推出，选择其他的先不做操作也不做退出程序</p><pre class=" language-c++"><code class="language-c++"> while (1)    {         showMenu();        int choose = 0;        cout << "请输入你的选项：" << endl;        cin >> choose;        switch (choose)        {        case 1: //添加联系人            break;        case 2: //显示联系人            break;        case 3: //删除联系人            break;        case 4: //查找联系人            break;        case 5: //修改联系人            break;        case 6: //清空联系人            break;        case 0: //退出联系人0            cout << "欢迎下次使用" << endl;            system("pause"); //按任意键            return 0;        //退出程序            break;        default:            break;        }    }</code></pre><h3 id="3、添加联系人"><a href="#3、添加联系人" class="headerlink" title="3、添加联系人"></a>3、添加联系人</h3><p>联系人上限为1000人，联系人信息包括：姓名、性别、年龄、联系电话、家庭住址</p><p>思路步骤：</p><ul><li><p>设计联系人结构体</p></li><li><p>设计通讯录结构体</p></li><li><p>main()函数中创建通讯录</p></li><li><p>封装添加联系人函数</p></li><li><p>测试添加联系人功能</p></li></ul><h4 id="3-1设计联系人结构体"><a href="#3-1设计联系人结构体" class="headerlink" title="3.1设计联系人结构体"></a>3.1设计联系人结构体</h4><p>联系人信息包括：姓名、性别、年龄、联系电话、家庭住址</p><pre class=" language-c++"><code class="language-c++">//创建联系人结构体struct Person{    string name;//姓名    string sex;//性别 1、男 2、女    int age;//年龄    string phone;//电话    string address;//住址};</code></pre><h4 id="3-2-设计通讯录结构体"><a href="#3-2-设计通讯录结构体" class="headerlink" title="3.2 设计通讯录结构体"></a>3.2 设计通讯录结构体</h4><p>设计可以在通讯录结构体中，维护一个容量为1000的存放联系人的数组，并记录当前通讯录中联系人数量</p><pre class=" language-c++"><code class="language-c++">#define MAX 1000//最大人数//创建通讯录结构体struct addbooks{    struct Person p[MAX];//通讯录中保存的联系人数组    int size;//通讯录中当前记录联系人个数};</code></pre><ul><li>system是调用系统指令</li><li>system(“pause”)   //按任意键继续</li><li>system(“cls”)   //清屏操作</li></ul><h4 id="3-3-main函数中创建通讯录"><a href="#3-3-main函数中创建通讯录" class="headerlink" title="3.3 main函数中创建通讯录"></a>3.3 main函数中创建通讯录</h4><p>在main函数中创建一个通讯录变量，这个就是我们需要一直维护的通讯录</p><pre class=" language-c++"><code class="language-c++">main函数中添加：    //创建通讯录结构体变量    addbooks abs;    //初始化通讯录中当前人员格式    abs.size = 0;</code></pre><h4 id="3-4-封装添加联系人函数"><a href="#3-4-封装添加联系人函数" class="headerlink" title="3.4 封装添加联系人函数"></a>3.4 封装添加联系人函数</h4><p>思路：添加联系人前先判断通讯录是否已经满了，如果满了就不再添加了，未满情况将联系人信息逐步添加到通讯录当中</p><pre class=" language-c++"><code class="language-c++">//1、添加联系人函数void addPerson(addbooks *abs){    //判断通信录是否已满，如果满了就不再添加了    if (abs->size ==MAX)    {        cout << "通讯录已满，无法添加！" << endl;    }    else    {        //添加具体联系人        //添加姓名；        string name;        cout << "请输入姓名:" << endl;        cin >> name;        abs->p[abs->size].name = name;        //添加性别        int sex = 0;        cout << "请输入性别:" << endl;        cout << "1-----男" << endl;        cout << "2-----女" << endl;        while (1)        {            //如果输入的是1、2，则可以退出循环，            //若输入有误，则重新输入            cin >> sex;            if (sex == 1||sex == 2 )        {            abs->p[abs->size].sex = sex;            break;//退出循环        }                   cout << "您输入有误，请重新输入" << endl;                   }        //添加年龄        int age = 0;        cout << "请输入年龄:" << endl;        cin >> age;        abs->p[abs->size].age = age;        //添加联系电话        string Phone;        cout << "请输入联系电话:" << endl;        cin >> Phone;        abs->p[abs->size].phone = Phone;        //添加家庭住址        string address;        cout << "请输入家庭住址:" << endl;        cin >> address;        abs->p[abs->size].address = address;        //更新通讯录里的人数        abs->size++;        cout << "添加成功" << endl;        system("pause");//请按任意键继续        system("cls");//清屏操作    }}</code></pre><h4 id="3-5-添加联系人功能"><a href="#3-5-添加联系人功能" class="headerlink" title="3.5 添加联系人功能"></a>3.5 添加联系人功能</h4><p>main函数switch语句里面添加：</p><pre class=" language-c++"><code class="language-c++">case 1: //添加联系人            addPerson(&abs);//利用地址传递可以修饰实参            break;</code></pre><h3 id="4、显示联系人"><a href="#4、显示联系人" class="headerlink" title="4、显示联系人"></a>4、显示联系人</h3><p>显示通讯录中已有的联系人信息</p><p>实现步骤：</p><ul><li><p>封装显示联系人函数</p></li><li><p>测试显示联系人功能</p></li></ul><h4 id="4-1-封装显示联系人函数"><a href="#4-1-封装显示联系人函数" class="headerlink" title="4.1 封装显示联系人函数"></a>4.1 封装显示联系人函数</h4><p>判断如果当前通讯录中没有人员，就提示记录为空，人数大于0时，就显示通讯录中的信息</p><pre class=" language-c++"><code class="language-c++">//2、显示所有的联系人void showPerson(addbooks *abs){    //判断通讯录中人数是否为0，如果为0，提示记录为空    //如果不为0，则显示通讯录中的联系人信息    if (abs->size == 0)    {        cout << "通讯录当前为空！" << endl;    }    else    {        for (int i = 0; i < abs->size; i++)//类似于遍历数组        {            cout << "姓名：" << abs->p[i].name << "\t";            //三目运算符，如果为1，返回为男，否则，返回为女            cout << "性别：" << (abs->p[i].sex ==1?"男":"女") <<"\t";            cout << "年龄：" << abs->p[i].age << "\t";            cout << "电话：" << abs->p[i].phone << "\t";            cout << "家庭住址：" << abs->p[i].address << endl;        }    }    system("pause");    system("cls");}</code></pre><h3 id="5、删除联系人"><a href="#5、删除联系人" class="headerlink" title="5、删除联系人"></a>5、删除联系人</h3><p>按照姓名进行删除指定联系人</p><ul><li>封装检测联系人是否存在</li><li>封装删除联系人函数</li><li>测试删除联系人功能</li></ul><h4 id="4-1-封装检测联系人是否存在"><a href="#4-1-封装检测联系人是否存在" class="headerlink" title="4.1 封装检测联系人是否存在"></a>4.1 封装检测联系人是否存在</h4><p>删除联系人之前，我们首先需要判断用户输入的联系人是否存在，如果存在则删除，否则提示用户没有要删除的联系人，因此可以把检测联系人是否存在封装成一个函数，如果存在，返回联系人在通讯录中的位置，不存在返回-1</p><ul><li>switch 语句中，break上面的代码若有多行时，应用{}括起来，形成代码段，否则会报错</li></ul><pre class=" language-c++"><code class="language-c++">//检测联系人是否存在，如果存在，返回联系人所在数组中的具体位置，不存在返回-1//参数1 通讯录   参数2  对比姓名int check(addbooks * abs,string name){    for (int i = 0; i < abs->size; i++)    {        if (abs->p[i].name == name)        {            return i; //找到了，返回这个人在数组中的下标编号        }                   }    return -1; //如果遍历结束都没找到，返回-1}main函数中： case 3: //删除联系人           { cout << "请输入删除联系人的姓名：" << endl;            string name;            cin >> name;            if (check(&abs,name) == -1)            {                cout << "查无此人" << endl;            }            else            {                cout << "找到此人" << endl;            }           }</code></pre><h4 id="4-2-封装删除联系人函数"><a href="#4-2-封装删除联系人函数" class="headerlink" title="4.2 封装删除联系人函数"></a>4.2 封装删除联系人函数</h4><ul><li><p>要删除李四，将李四后的数据做前向移动，并且让通讯录中记录的人员做-1操作</p></li><li><p>   <em>//数据迁移,可以整体迁移</em></p></li></ul><p>  ​      abs-&gt;p[i] = abs-&gt;p[i + 1];</p><pre class=" language-c++"><code class="language-c++">/3、删除指定联系人void deletePerson(addbooks *abs){    cout << "请输入你要删除的联系人：" << endl;    string name;    cin >> name;    //ret = -1   未查到    //ret ！= -1 查到了    int ret = check(abs, name);    if (ret != -1)    {        //查找到此人进行删除的操作        for (int i = ret; i < abs->size; i++)        {            //数据迁移,可以整体迁移            abs->p[i] = abs->p[i + 1];        }        abs->size--; //更新通讯录中的人员数；        cout << "删除成功了" << endl;    }    else    {        cout << "查无此人" << endl;    }    system("pause");    system("cls");}</code></pre><h3 id="6、查找联系人"><a href="#6、查找联系人" class="headerlink" title="6、查找联系人"></a>6、查找联系人</h3><p>按照姓名查看指定联系人信息</p><ul><li><p>封装查找联系人函数</p></li><li><p>测试查找指定联系人</p></li></ul><h4 id="6-1-封装查找联系人函数"><a href="#6-1-封装查找联系人函数" class="headerlink" title="6.1 封装查找联系人函数"></a>6.1 封装查找联系人函数</h4><p>判断用户指定的联系人是否存在，如果存在则显示信息，不存在则提示查无此人</p><pre class=" language-c++"><code class="language-c++">//4、查找指定联系人信息void findPerson(addbooks *abs){    cout << "请输入你要查找的联系人" << endl;    string name;    cin >> name;    //判断指定的联系人是否存在    int fin = check(abs, name);    if (fin != -1) //找到了    {        cout << "姓名：" << abs->p[fin].name << "\t";        //三目运算符，如果为1，返回为男，否则，返回为女        cout << "性别：" << (abs->p[fin].sex == 1 ? "男" : "女") << "\t";        cout << "年龄：" << abs->p[fin].age << "\t";        cout << "电话：" << abs->p[fin].phone << "\t";        cout << "家庭住址：" << abs->p[fin].address << endl;    }    else //未找到    {        cout << "查无此人" << endl;    }    system("pause");    system("cls");}</code></pre><h3 id="7、修改联系人"><a href="#7、修改联系人" class="headerlink" title="7、修改联系人"></a>7、修改联系人</h3><p>按照姓名重新修改指定联系人</p><ul><li><p>封装修改联系人函数</p></li><li><p>测试修改联系人功能</p></li></ul><h4 id="7-1-封装修改联系人函数"><a href="#7-1-封装修改联系人函数" class="headerlink" title="7.1 封装修改联系人函数"></a>7.1 封装修改联系人函数</h4><p>查找用户输入的联系人，如果朝朝成功进行修改操作，查找失败则提示查无此人</p><pre class=" language-c++"><code class="language-c++">//5、修改联系人void changePerson(addbooks * abs){    cout << "请输入你要查找的联系人" << endl;    string name;    cin >> name;    int ret = check(abs, name);    if (ret!=-1)//找到联系人    {        //姓名        cout << "请输入姓名：" << endl;        string name;        cin >> name;        abs->p[ret].name = name;        //性别        cout << "请输入性别：" << endl;        cout << "1-----男" << endl;        cout << "2-----女" << endl;        int sex = 0;         while (1)        {            //如果输入的是1、2，则可以退出循环，            //若输入有误，则重新输入            cin >> sex;            if (sex == 1 || sex == 2)            {                abs->p[ret].sex = sex;                break; //退出循环            }            cout << "您输入有误，请重新输入" << endl;        }                //年龄        cout << "请输入年龄：" << endl;        int age;        cin >> age;        abs->p[ret].age = age;        //电话        cout << "请输入联系电话：" << endl;        string phone;        cin >> phone;        abs->p[ret].phone = phone;        //住址        cout << "请输入家庭住址：" << endl;        string address;        cin >> address;        abs->p[ret].address = address;        cout << "修改成功" << endl;    }    else //未找到联系人    {        cout << "查无此人" << endl;    }    //按任意键清屏    system("pause");    system("cls");}</code></pre><h3 id="8、清空联系人"><a href="#8、清空联系人" class="headerlink" title="8、清空联系人"></a>8、清空联系人</h3><p>清空通讯录中所有信息</p><ul><li><p>封装清空联系人函数</p></li><li><p>测试清空联系人</p></li></ul><h4 id="10-1-封装清空联系人函数"><a href="#10-1-封装清空联系人函数" class="headerlink" title="10.1 封装清空联系人函数"></a>10.1 封装清空联系人函数</h4><p>将通讯录所有联系人信息清除掉，只要将通讯录记录的联系人人数置为0，做逻辑清空即可</p><ul><li>只是逻辑清空，内存在定义的时候就已经分配好了</li><li>但是关闭之后也自然释放内存了</li><li>==是逻辑判断，=是赋值</li></ul><pre class=" language-c++"><code class="language-c++">void cleanPerson(addbooks *abs){    abs->size = 0; //将当前记录联系人数量置为0，做逻辑清空操作    cout << "通讯录已清空" << endl;    system("pause");    system("cls");}main函数中： case 6: //清空联系人        {            cout << "你确定要清空数据吗" << endl;            cout << "1---确定" << endl;            cout << "2---误操作" << endl;            int an = 0;            cin >> an;            switch (an)            {            case 1:                cleanPerson(&abs);                break;            case 2:                cout << "别再手滑了哦" << endl;                system("pause");                system("cls");                break;            default:                break;            }        }</code></pre><h3 id="9、完整程序展示"><a href="#9、完整程序展示" class="headerlink" title="9、完整程序展示"></a>9、完整程序展示</h3><p>优化了一些内容，更加人性化，啦啦啦，满满的成就感</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;#define MAX 1000 //最大人数//菜单界面void showMenu(){    cout << "**************************" << endl;    cout << "*****  1、添加联系人  *****" << endl;    cout << "*****  2、显示联系人  *****" << endl;    cout << "*****  3、删除联系人  *****" << endl;    cout << "*****  4、查找联系人  *****" << endl;    cout << "*****  5、修改联系人  *****" << endl;    cout << "*****  6、清空联系人  *****" << endl;    cout << "*****  0、退出联系人  *****" << endl;    cout << "**************************" << endl;};//创建联系人结构体struct Person{    string name;    //姓名    int sex;        //性别 1、男 2、女    int age;        //年龄    string phone;   //电话    string address; //住址};//创建通讯录结构体struct addbooks{    struct Person p[MAX]; //通讯录中保存的联系人数组    int size;             //通讯录中当前记录联系人个数};//1、添加联系人函数void addPerson(addbooks *abs){    //判断通信录是否已满，如果满了就不再添加了    if (abs->size == MAX)    {        cout << "通讯录已满，无法添加！" << endl;    }    else    {        //添加具体联系人        //添加姓名；        string name;        cout << "请输入姓名:" << endl;        cin >> name;        abs->p[abs->size].name = name;        //添加性别        int sex = 0;        cout << "请输入性别:" << endl;        cout << "1-----男" << endl;        cout << "2-----女" << endl;        while (1)        {            //如果输入的是1、2，则可以退出循环，            //若输入有误，则重新输入            cin >> sex;            if (sex == 1 || sex == 2)            {                abs->p[abs->size].sex = sex;                break; //退出循环            }            cout << "您输入有误，请重新输入" << endl;        }        //添加年龄        int age = 0;        cout << "请输入年龄:" << endl;        cin >> age;        abs->p[abs->size].age = age;        //添加联系电话        string Phone;        cout << "请输入联系电话:" << endl;        cin >> Phone;        abs->p[abs->size].phone = Phone;        //添加家庭住址        string address;        cout << "请输入家庭住址:" << endl;        cin >> address;        abs->p[abs->size].address = address;        //更新通讯录里的人数        abs->size++;        cout << "添加成功" << endl;        system("pause"); //请按任意键继续        system("cls");   //清屏操作    }}//2、显示所有的联系人void showPerson(addbooks *abs){    //判断通讯录中人数是否为0，如果为0，提示记录为空    //如果不为0，则显示通讯录中的联系人信息    if (abs->size == 0)    {        cout << "通讯录当前为空！" << endl;    }    else    {        for (int i = 0; i < abs->size; i++) //类似于遍历数组        {            cout << "姓名：" << abs->p[i].name << "\t";            //三目运算符，如果为1，返回为男，否则，返回为女            cout << "性别：" << (abs->p[i].sex == 1 ? "男" : "女") << "\t";            cout << "年龄：" << abs->p[i].age << "\t";            cout << "电话：" << abs->p[i].phone << "\t";            cout << "家庭住址：" << abs->p[i].address << endl;        }    }    system("pause");    system("cls");}//检测联系人是否存在，如果存在，返回联系人所在数组中的具体位置，不存在返回-1//参数1 通讯录   参数2  对比姓名int check(addbooks *abs, string name){    for (int i = 0; i < abs->size; i++)    {        if (abs->p[i].name == name)        {            return i; //找到了，返回这个人在数组中的下标编号        }    }    return -1; //如果遍历结束都没找到，返回-1}//3、删除指定联系人void deletePerson(addbooks *abs){    cout << "请输入你要删除的联系人：" << endl;    string name;    cin >> name;    //ret = -1   未查到    //ret ！= -1 查到了    int ret = check(abs, name);    if (ret != -1)    {        //查找到此人进行删除的操作        for (int i = ret; i < abs->size; i++)        {            //数据迁移,可以整体迁移            abs->p[i] = abs->p[i + 1];        }        abs->size--; //更新通讯录中的人员数；        cout << "删除成功了" << endl;    }    else    {        cout << "查无此人" << endl;    }    system("pause");    system("cls");}//4、查找指定联系人信息void findPerson(addbooks *abs){    cout << "请输入你要查找的联系人" << endl;    string name;    cin >> name;    //判断指定的联系人是否存在    int fin = check(abs, name);    if (fin != -1) //找到了    {        cout << "姓名：" << abs->p[fin].name << "\t";        //三目运算符，如果为1，返回为男，否则，返回为女        cout << "性别：" << (abs->p[fin].sex == 1 ? "男" : "女") << "\t";        cout << "年龄：" << abs->p[fin].age << "\t";        cout << "电话：" << abs->p[fin].phone << "\t";        cout << "家庭住址：" << abs->p[fin].address << endl;    }    else //未找到    {        cout << "查无此人" << endl;    }    system("pause");    system("cls");}//5、修改联系人void changePerson(addbooks *abs){    cout << "请输入你要查找的联系人" << endl;    string name;    cin >> name;    int ret = check(abs, name);    if (ret != -1) //找到联系人    {        //姓名        cout << "请输入姓名：" << endl;        string name;        cin >> name;        abs->p[ret].name = name;        //性别        cout << "请输入性别：" << endl;        cout << "1-----男" << endl;        cout << "2-----女" << endl;        int sex = 0;        while (1)        {            //如果输入的是1、2，则可以退出循环，            //若输入有误，则重新输入            cin >> sex;            if (sex == 1 || sex == 2)            {                abs->p[ret].sex = sex;                break; //退出循环            }            cout << "您输入有误，请重新输入" << endl;        }        //年龄        cout << "请输入年龄：" << endl;        int age;        cin >> age;        abs->p[ret].age = age;        //电话        cout << "请输入联系电话：" << endl;        string phone;        cin >> phone;        abs->p[ret].phone = phone;        //住址        cout << "请输入家庭住址：" << endl;        string address;        cin >> address;        abs->p[ret].address = address;        cout << "修改成功" << endl;    }    else //未找到联系人    {        cout << "查无此人" << endl;    }    //按任意键清屏    system("pause");    system("cls");}void cleanPerson(addbooks *abs){    abs->size = 0; //将当前记录联系人数量置为0，做逻辑清空操作    cout << "通讯录已清空" << endl;    system("pause");    system("cls");}int main(){    //创建通讯录结构体变量    addbooks abs;    //初始化通讯录中当前人员格式    abs.size = 0;    //在main函数中调用封装好的函数    while (1)    {        showMenu();        int choose = 0;        cout << "请输入你的选项：" << endl;        cin >> choose;        switch (choose)        {        case 1:              //添加联系人            addPerson(&abs); //利用地址传递可以修饰实参            break;        case 2: //显示联系人            showPerson(&abs);            break;        case 3: //删除联系人            // {            //     cout << "请输入删除联系人的姓名：" << endl;            //     string name;            //     cin >> name;            //     if (check(&abs, name) == -1)            //     {            //         cout << "查无此人" << endl;            //     }            //     else            //     {            //         cout << "找到此人" << endl;            //     }            // }            deletePerson(&abs);            break;        case 4: //查找联系人            findPerson(&abs);            break;        case 5: //修改联系人            changePerson(&abs);            break;        case 6: //清空联系人        {            cout << "你确定要清空数据吗" << endl;            cout << "1---确定" << endl;            cout << "2---误操作" << endl;            int an = 0;            cin >> an;            switch (an)            {            case 1:                cleanPerson(&abs);                break;            case 2:                cout << "别再手滑了哦" << endl;                system("pause");                system("cls");                break;            default:                break;            }        }        break;        case 0: //退出联系人0            cout << "欢迎下次使用" << endl;            system("pause"); //按任意键            return 0;        //退出程序            break;        default:            break;        }    }    system("pause"); //程序不会一闪而过    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++开发环境搭建</title>
      <link href="2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/"/>
      <url>2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="基于VS-Code-搭建轻量便捷的C-开发环境"><a href="#基于VS-Code-搭建轻量便捷的C-开发环境" class="headerlink" title="基于VS Code 搭建轻量便捷的C++开发环境"></a>基于VS Code 搭建轻量便捷的C++开发环境</h1> <span id="more"></span><blockquote><p>最近正在学习C++,一款强大的编译器当然是必不可少的啦！前后试用了Visual Studio、Dev-Cpp、Notepad++、 CodeBlocks之类的编译器，最后真的感觉 嗯！ VS Code，真香！ 既可以快速运行单文件的小练习，也可以配合Cmake开发工程 舒服的代码高亮和智能补全、快速跳转简直不要太好用！前期的摸索当中看了好多资料（网上很多称作是看一篇就够了，但感觉写的却非常模糊），当然也走了很多弯路，浪费了不少时间，综上，总结一下环境搭建流程，适合小白，亲测有效！</p></blockquote><h2 id="一、明确目的、理清思路"><a href="#一、明确目的、理清思路" class="headerlink" title="一、明确目的、理清思路"></a>一、明确目的、理清思路</h2><p>首先明确一下VS Code只是一个代码编译器，能编译、调试、运行就完事了，可以理解为我们之前使用的DevC++增加了用户体验，替换了舒适手感就变为VS Code了，接下来是我们需要解决的完成的一些任务</p><ul><li><p>使用VS Code编译C++代码：需要安装编译器</p></li><li><p>使用VS Code可以编译、调试、运行程序：需要安装插件，且需要添加两个json为文件</p></li><li><p>若VS Code编译头文件库时报错：需要添加.h文件库的位置（==本人在这点踩坑了==）</p></li></ul><h2 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a>二、具体步骤</h2><h3 id="1、下载安装解决编译器问题"><a href="#1、下载安装解决编译器问题" class="headerlink" title="1、下载安装解决编译器问题"></a>1、下载安装解决编译器问题</h3><ul><li>首先下载VS Code(官网即可)，正常安装，遇到打勾的全选即可</li></ul><ul><li><p>下载安装编译器，我这里使用的是ming-w64 ，ming-w64下载（c++的工具包） 官方：<a href="https://sourceforge.net/projects/mingw-w64/">https://sourceforge.net/projects/mingw-w64/</a></p><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/1.png" class=""><p>==一定要下载该版本，否则没有bin文件，亲测==</p><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/2.png" class=""><p>==路径是不可以有中文或空格的，可能会导致gdb无法正常工作没有办法debug放不了断点什么的了==</p><p>下载好VS Code之后需要把bin文件的路径添加到系统的PATH里面</p><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/3.png" class=""><p>配置好之后输入cmd，输入 gcc -v 查看gcc版本即可如下图</p><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/4.png" class=""></li></ul><h3 id="2、安装VS-Code插件"><a href="#2、安装VS-Code插件" class="headerlink" title="2、安装VS Code插件"></a>2、安装VS Code插件</h3><ul><li><p>下载安装完之后，VS Code是空的，打开VS Code装几个插件，你需要什么功能就去下载什么功能，可以理解为手机里的应用商店。</p><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/5.png" class=""><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/6.png" class=""></li></ul><ul><li>输入需要下载的插件，比如安装C/C++ ,Code  Runner就可以意见运行程序了，可以选择性的添加想要的插件</li></ul><h3 id="3、运行调试程序，配置文件"><a href="#3、运行调试程序，配置文件" class="headerlink" title="3、运行调试程序，配置文件"></a>3、运行调试程序，配置文件</h3><ul><li><p>接下来新建一个我们代码存放的文件夹（电脑上习惯的位置）用于存放代码，接下来配置好的调试环境，进队存放在这一个文件夹及文件夹的子目录里的程序作用</p><p>上面就是我在电脑里创建的一个用于存放.cpp文件的文件夹</p><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/7.png" class=""></li><li><p>接下来配置文件让程序编译起来，在文件夹下新建.VS Code文件夹并新建两个<code>json</code>文件分别是<code>launch.json</code> 和<code>task.json </code></p><ul><li><code>launch.json</code> 配置启动的一些参数</li><li><code>task.json</code> 配置编译器的相关参数  可以用最新的c++编译器</li></ul><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/8.png" class=""><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/9.png" class=""></li></ul><p><code> "externalConsole": false,</code> <em>// 为true时使用单独的cmd窗口，与其它IDE一致；18年10月后设为false可调用VSC内置终端</em></p><p>  另外<code>shift +alt+f</code>   自动整理代码 （非常好用，强推）</p><h3 id="4、头文件报错怎么办"><a href="#4、头文件报错怎么办" class="headerlink" title="4、头文件报错怎么办"></a>4、头文件报错怎么办</h3><p>也就是我遇到的最头疼的问题，在我们VS Code代码写了一大半回过头时，就会发现</p><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/10.png" class=""><p>what?库函数都找不到？这个问题也是纠缠我时间最长的问题，很多资料帖子都没有写的很清楚，但我认为应该是很多人遇到的问题吧。</p><p>经过不断查找、询问、试错之后我发现，VS Code找不到都文件的问题是由于windows下VS Code默认的编译器是微软的MSVC(Microsoft Visual Studio使用的编译器）的头文件路径，如果没有安装Microsoft Visual Studio肯定会因为炸不到头文件而报错的，所有我们要手动修改配置。</p><p>ctrl +shift +p ,”C/Cpp:Edit configurations”,生成c_cpp_properties.json文件如图，在这个文件里需要修改基础，如includePath和compilerPath：</p><img src="/2021/05/10/ji-yu-vscode-da-jian-qing-liang-bian-jie-de-c-kai-fa-huan-jing/11.png" class=""><p>还要想添加其他的库，都可以用这样的方式进行添加，上面的配置完成之后，再回到你创建的.cpp文件，你就会发现不会报错了</p><blockquote><p>基于VS Code 搭建轻量便捷的C++开发环境配置完毕，其实过程还是非常简单的，把我的经验记录分享给大家，加油！</p></blockquote><blockquote><p>Good  Luck   to   you!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS Code </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
